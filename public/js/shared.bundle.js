!function(g){var t={};function n(I){if(t[I])return t[I].exports;var e=t[I]={i:I,l:!1,exports:{}};return g[I].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=g,n.c=t,n.d=function(g,t,I){n.o(g,t)||Object.defineProperty(g,t,{configurable:!1,enumerable:!0,get:I})},n.n=function(g){var t=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(t,"a",t),t},n.o=function(g,t){return Object.prototype.hasOwnProperty.call(g,t)},n.p="",n(n.s=0)}([
/*!*****************************!*\
  !*** ./client/js/shared.js ***!
  \*****************************/
/*! dynamic exports provided */
/*! all exports used */function(module,exports,__webpack_require__){"use strict";eval('\n\n__webpack_require__(/*! bootstrap.native/dist/bootstrap-native-v4 */ 1);\n\n__webpack_require__(/*! ./../styles/site.scss */ 3);\n\n/* SHARED MODULES USED IN EVERY PAGE\n*\n* In this file you can import JS or SCSS file wchich are shared on every page,\n* basic configuration includes bootstrap-native-v4, and site.scss for entry point to sass loader\n*\n*/\nconsole.log("shared JS imported");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jbGllbnQvanMvc2hhcmVkLmpzP2QxODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogU0hBUkVEIE1PRFVMRVMgVVNFRCBJTiBFVkVSWSBQQUdFXG4qXG4qIEluIHRoaXMgZmlsZSB5b3UgY2FuIGltcG9ydCBKUyBvciBTQ1NTIGZpbGUgd2NoaWNoIGFyZSBzaGFyZWQgb24gZXZlcnkgcGFnZSxcbiogYmFzaWMgY29uZmlndXJhdGlvbiBpbmNsdWRlcyBib290c3RyYXAtbmF0aXZlLXY0LCBhbmQgc2l0ZS5zY3NzIGZvciBlbnRyeSBwb2ludCB0byBzYXNzIGxvYWRlclxuKlxuKi9cbmltcG9ydCAnYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQnO1xuaW1wb3J0ICcuLy4uL3N0eWxlcy9zaXRlLnNjc3MnO1xuXG5jb25zb2xlLmxvZyhcInNoYXJlZCBKUyBpbXBvcnRlZFwiKVxuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjbGllbnQvanMvc2hhcmVkLmpzIl0sIm1hcHBpbmdzIjoiOztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBUkE7Ozs7OztBQVNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},
/*!*******************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native-v4.js ***!
  \*******************************************************************/
/*! dynamic exports provided */
/*! all exports used */function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Native Javascript for Bootstrap 4 v2.0.22 | Â© dnp_theme | MIT-License\n(function (root, factory) {\n  if (true) {\n    // AMD support:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module === 'object' && module.exports) {\n    // CommonJS-like:\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    var bsn = factory();\n    root.Alert = bsn.Alert;\n    root.Button = bsn.Button;\n    root.Carousel = bsn.Carousel;\n    root.Collapse = bsn.Collapse;\n    root.Dropdown = bsn.Dropdown;\n    root.Modal = bsn.Modal;\n    root.Popover = bsn.Popover;\n    root.ScrollSpy = bsn.ScrollSpy;\n    root.Tab = bsn.Tab;\n    root.Tooltip = bsn.Tooltip;\n  }\n}(this, function () {\n  \n  /* Native Javascript for Bootstrap 4 | Internal Utility Functions\n  ----------------------------------------------------------------*/\n  \"use strict\";\n  \n  // globals\n  var globalObject = typeof global !== 'undefined' ? global : this||window,\n    DOC = document, HTML = DOC.documentElement, body = 'body', // allow the library to be used in <head>\n  \n    // Native Javascript for Bootstrap Global Object\n    BSN = globalObject.BSN = {},\n    supports = BSN.supports = [],\n  \n    // function toggle attributes\n    dataToggle    = 'data-toggle',\n    dataDismiss   = 'data-dismiss',\n    dataSpy       = 'data-spy',\n    dataRide      = 'data-ride',\n  \n    // components\n    stringAlert     = 'Alert',\n    stringButton    = 'Button',\n    stringCarousel  = 'Carousel',\n    stringCollapse  = 'Collapse',\n    stringDropdown  = 'Dropdown',\n    stringModal     = 'Modal',\n    stringPopover   = 'Popover',\n    stringScrollSpy = 'ScrollSpy',\n    stringTab       = 'Tab',\n    stringTooltip   = 'Tooltip',\n  \n    // options DATA API\n    databackdrop      = 'data-backdrop',\n    dataKeyboard      = 'data-keyboard',\n    dataTarget        = 'data-target',\n    dataInterval      = 'data-interval',\n    dataHeight        = 'data-height',\n    dataPause         = 'data-pause',\n    dataTitle         = 'data-title',\n    dataOriginalTitle = 'data-original-title',\n    dataOriginalText  = 'data-original-text',\n    dataDismissible   = 'data-dismissible',\n    dataTrigger       = 'data-trigger',\n    dataAnimation     = 'data-animation',\n    dataContainer     = 'data-container',\n    dataPlacement     = 'data-placement',\n    dataDelay         = 'data-delay',\n    dataOffsetTop     = 'data-offset-top',\n    dataOffsetBottom  = 'data-offset-bottom',\n  \n    // option keys\n    backdrop = 'backdrop', keyboard = 'keyboard', delay = 'delay',\n    content = 'content', target = 'target',\n    interval = 'interval', pause = 'pause', animation = 'animation',\n    placement = 'placement', container = 'container',\n  \n    // box model\n    offsetTop    = 'offsetTop',      offsetBottom   = 'offsetBottom',\n    offsetLeft   = 'offsetLeft',\n    scrollTop    = 'scrollTop',      scrollLeft     = 'scrollLeft',\n    clientWidth  = 'clientWidth',    clientHeight   = 'clientHeight',\n    offsetWidth  = 'offsetWidth',    offsetHeight   = 'offsetHeight',\n    innerWidth   = 'innerWidth',     innerHeight    = 'innerHeight',\n    scrollHeight = 'scrollHeight',   height         = 'height',\n  \n    // aria\n    ariaExpanded = 'aria-expanded',\n    ariaHidden   = 'aria-hidden',\n  \n    // event names\n    clickEvent    = 'click',\n    hoverEvent    = 'hover',\n    keydownEvent  = 'keydown',\n    keyupEvent    = 'keyup', \n    resizeEvent   = 'resize',\n    scrollEvent   = 'scroll',\n    // originalEvents\n    showEvent     = 'show',\n    shownEvent    = 'shown',\n    hideEvent     = 'hide',\n    hiddenEvent   = 'hidden',\n    closeEvent    = 'close',\n    closedEvent   = 'closed',\n    slidEvent     = 'slid',\n    slideEvent    = 'slide',\n    changeEvent   = 'change',\n  \n    // other\n    getAttribute           = 'getAttribute',\n    setAttribute           = 'setAttribute',\n    hasAttribute           = 'hasAttribute',\n    createElement          = 'createElement',\n    appendChild            = 'appendChild',\n    innerHTML              = 'innerHTML',  \n    getElementsByTagName   = 'getElementsByTagName',\n    preventDefault         = 'preventDefault',\n    getBoundingClientRect  = 'getBoundingClientRect',\n    querySelectorAll       = 'querySelectorAll',\n    getElementsByCLASSNAME = 'getElementsByClassName',\n  \n    indexOf      = 'indexOf',\n    parentNode   = 'parentNode',\n    length       = 'length',\n    toLowerCase  = 'toLowerCase',\n    Transition   = 'Transition',\n    Webkit       = 'Webkit',\n    style        = 'style',\n    push         = 'push',\n    tabindex     = 'tabindex',\n    contains     = 'contains',\n  \n    active     = 'active',\n    showClass  = 'show',\n    collapsing = 'collapsing',\n    disabled   = 'disabled',\n    loading    = 'loading',\n    left       = 'left',\n    right      = 'right',\n    top        = 'top',\n    bottom     = 'bottom',\n  \n    // tooltip / popover\n    mouseHover = ('onmouseleave' in DOC) ? [ 'mouseenter', 'mouseleave'] : [ 'mouseover', 'mouseout' ],\n    tipPositions = /\\b(top|bottom|left|right)+/,\n    \n    // modal\n    modalOverlay = 0,\n    fixedTop = 'fixed-top',\n    fixedBottom = 'fixed-bottom',\n    \n    // transitionEnd since 2.0.4\n    supportTransitions = Webkit+Transition in HTML[style] || Transition[toLowerCase]() in HTML[style],\n    transitionEndEvent = Webkit+Transition in HTML[style] ? Webkit[toLowerCase]()+Transition+'End' : Transition[toLowerCase]()+'end',\n  \n    // set new focus element since 2.0.3\n    setFocus = function(element){\n      element.focus ? element.focus() : element.setActive();\n    },\n  \n    // class manipulation, since 2.0.0 requires polyfill.js\n    addClass = function(element,classNAME) {\n      element.classList.add(classNAME);\n    },\n    removeClass = function(element,classNAME) {\n      element.classList.remove(classNAME);\n    },\n    hasClass = function(element,classNAME){ // since 2.0.0\n      return element.classList[contains](classNAME);\n    },\n  \n    // selection methods\n    getElementsByClassName = function(element,classNAME) { // returns Array\n      return [].slice.call(element[getElementsByCLASSNAME]( classNAME ));\n    },\n    queryElement = function (selector, parent) {\n      var lookUp = parent ? parent : DOC;\n      return typeof selector === 'object' ? selector : lookUp.querySelector(selector);\n    },\n    getClosest = function (element, selector) { //element is the element and selector is for the closest parent element to find\n      // source http://gomakethings.com/climbing-up-and-down-the-dom-tree-with-vanilla-javascript/\n      var firstChar = selector.charAt(0), selectorSubstring = selector.substr(1);\n      if ( firstChar === '.' ) {// If selector is a class\n        for ( ; element && element !== DOC; element = element[parentNode] ) { // Get closest match\n          if ( queryElement(selector,element[parentNode]) !== null && hasClass(element,selectorSubstring) ) { return element; }\n        }\n      } else if ( firstChar === '#' ) { // If selector is an ID\n        for ( ; element && element !== DOC; element = element[parentNode] ) { // Get closest match\n          if ( element.id === selectorSubstring ) { return element; }\n        }\n      }\n      return false;\n    },\n  \n    // event attach jQuery style / trigger  since 1.2.0\n    on = function (element, event, handler) {\n      element.addEventListener(event, handler, false);\n    },\n    off = function(element, event, handler) {\n      element.removeEventListener(event, handler, false);\n    },\n    one = function (element, event, handler) { // one since 2.0.4\n      on(element, event, function handlerWrapper(e){\n        handler(e);\n        off(element, event, handlerWrapper);\n      });\n    },\n    emulateTransitionEnd = function(element,handler){ // emulateTransitionEnd since 2.0.4\n      if (supportTransitions) { one(element, transitionEndEvent, function(e){ handler(e); }); }\n      else { handler(); }\n    },\n    bootstrapCustomEvent = function (eventName, componentName, related) {\n      var OriginalCustomEvent = new CustomEvent( eventName + '.bs.' + componentName);\n      OriginalCustomEvent.relatedTarget = related;\n      this.dispatchEvent(OriginalCustomEvent);\n    },\n  \n    // tooltip / popover stuff\n    getScroll = function() { // also Affix and ScrollSpy uses it\n      return {\n        y : globalObject.pageYOffset || HTML[scrollTop],\n        x : globalObject.pageXOffset || HTML[scrollLeft]\n      }\n    },\n    styleTip = function(link,element,position,parent) { // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n      var elementDimensions = { w : element[offsetWidth], h: element[offsetHeight] },\n          windowWidth = (HTML[clientWidth] || DOC[body][clientWidth]),\n          windowHeight = (HTML[clientHeight] || DOC[body][clientHeight]),\n          rect = link[getBoundingClientRect](),\n          scroll = parent === DOC[body] ? getScroll() : { x: parent[offsetLeft] + parent[scrollLeft], y: parent[offsetTop] + parent[scrollTop] },\n          linkDimensions = { w: rect[right] - rect[left], h: rect[bottom] - rect[top] },\n          isPopover = hasClass(element,'popover'),\n          topPosition, leftPosition, \n          \n          arrow = queryElement('.arrow',element),\n          arrowTop, arrowLeft, arrowWidth, arrowHeight,\n  \n          halfTopExceed = rect[top] + linkDimensions.h/2 - elementDimensions.h/2 < 0,\n          halfLeftExceed = rect[left] + linkDimensions.w/2 - elementDimensions.w/2 < 0,\n          halfRightExceed = rect[left] + elementDimensions.w/2 + linkDimensions.w/2 >= windowWidth,\n          halfBottomExceed = rect[top] + elementDimensions.h/2 + linkDimensions.h/2 >= windowHeight,\n          topExceed = rect[top] - elementDimensions.h < 0,\n          leftExceed = rect[left] - elementDimensions.w < 0,\n          bottomExceed = rect[top] + elementDimensions.h + linkDimensions.h >= windowHeight,\n          rightExceed = rect[left] + elementDimensions.w + linkDimensions.w >= windowWidth;\n  \n      // recompute position\n      position = (position === left || position === right) && leftExceed && rightExceed ? top : position; // first, when both left and right limits are exceeded, we fall back to top|bottom\n      position = position === top && topExceed ? bottom : position;\n      position = position === bottom && bottomExceed ? top : position;\n      position = position === left && leftExceed ? right : position;\n      position = position === right && rightExceed ? left : position;\n      \n      // update tooltip/popover class\n      element.className[indexOf](position) === -1 && (element.className = element.className.replace(tipPositions,position));\n  \n      // we check the computed width & height and update here\n      arrowWidth = arrow[offsetWidth]; arrowHeight = arrow[offsetHeight];\n  \n      // apply styling to tooltip or popover\n      if ( position === left || position === right ) { // secondary|side positions\n        if ( position === left ) { // LEFT\n          leftPosition = rect[left] + scroll.x - elementDimensions.w - ( isPopover ? arrowWidth : 0 );\n        } else { // RIGHT\n          leftPosition = rect[left] + scroll.x + linkDimensions.w;\n        }\n  \n        // adjust top and arrow\n        if (halfTopExceed) {\n          topPosition = rect[top] + scroll.y;\n          arrowTop = linkDimensions.h/2 - arrowWidth;\n        } else if (halfBottomExceed) {\n          topPosition = rect[top] + scroll.y - elementDimensions.h + linkDimensions.h;\n          arrowTop = elementDimensions.h - linkDimensions.h/2 - arrowWidth;\n        } else {\n          topPosition = rect[top] + scroll.y - elementDimensions.h/2 + linkDimensions.h/2;\n          arrowTop = elementDimensions.h/2 - (isPopover ? arrowHeight*0.9 : arrowHeight/2);\n        }\n      } else if ( position === top || position === bottom ) { // primary|vertical positions\n        if ( position === top) { // TOP\n          topPosition =  rect[top] + scroll.y - elementDimensions.h - ( isPopover ? arrowHeight : 0 );\n        } else { // BOTTOM\n          topPosition = rect[top] + scroll.y + linkDimensions.h;\n        }\n        // adjust left | right and also the arrow\n        if (halfLeftExceed) {\n          leftPosition = 0;\n          arrowLeft = rect[left] + linkDimensions.w/2 - arrowWidth;\n        } else if (halfRightExceed) {\n          leftPosition = windowWidth - elementDimensions.w*1.01;\n          arrowLeft = elementDimensions.w - ( windowWidth - rect[left] ) + linkDimensions.w/2 - arrowWidth/2;\n        } else {\n          leftPosition = rect[left] + scroll.x - elementDimensions.w/2 + linkDimensions.w/2;\n          arrowLeft = elementDimensions.w/2 - arrowWidth/2;\n        }\n      }\n  \n      // apply style to tooltip/popover and its arrow\n      element[style][top] = topPosition + 'px';\n      element[style][left] = leftPosition + 'px';\n  \n      arrowTop && (arrow[style][top] = arrowTop + 'px');\n      arrowLeft && (arrow[style][left] = arrowLeft + 'px');\n    };\n  \n  BSN.version = '2.0.22';\n  \n  /* Native Javascript for Bootstrap 4 | Alert\n  -------------------------------------------*/\n  \n  // ALERT DEFINITION\n  // ================\n  var Alert = function( element ) {\n    \n    // initialization element\n    element = queryElement(element);\n  \n    // bind, target alert, duration and stuff\n    var self = this, component = 'alert',\n      alert = getClosest(element,'.'+component),\n      triggerHandler = function(){ hasClass(alert,'fade') ? emulateTransitionEnd(alert,transitionEndHandler) : transitionEndHandler(); },\n      // handlers\n      clickHandler = function(e){\n        alert = getClosest(e[target],'.'+component);\n        element = queryElement('['+dataDismiss+'=\"'+component+'\"]',alert);\n        element && alert && (element === e[target] || element[contains](e[target])) && self.close();\n      },\n      transitionEndHandler = function(){\n        bootstrapCustomEvent.call(alert, closedEvent, component);\n        off(element, clickEvent, clickHandler); // detach it's listener\n        alert[parentNode].removeChild(alert);\n      };\n    \n    // public method\n    this.close = function() {\n      if ( alert && element && hasClass(alert,showClass) ) {\n        bootstrapCustomEvent.call(alert, closeEvent, component);\n        removeClass(alert,showClass);\n        alert && triggerHandler();\n      }\n    };\n  \n    // init\n    if ( !(stringAlert in element ) ) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    element[stringAlert] = self;\n  };\n  \n  // ALERT DATA API\n  // ==============\n  supports[push]([stringAlert, Alert, '['+dataDismiss+'=\"alert\"]']);\n  \n  \n  /* Native Javascript for Bootstrap 4 | Button\n  ---------------------------------------------*/\n  \n  // BUTTON DEFINITION\n  // ===================\n  var Button = function( element ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // constant\n    var toggled = false, // toggled makes sure to prevent triggering twice the change.bs.button events\n  \n        // strings\n        component = 'button',\n        checked = 'checked',\n        reset = 'reset',\n        LABEL = 'LABEL',\n        INPUT = 'INPUT',\n  \n      // private methods\n      keyHandler = function(e){ \n        var key = e.which || e.keyCode;\n        key === 32 && e[target] === DOC.activeElement && toggle(e);\n      },\n      preventScroll = function(e){ \n        var key = e.which || e.keyCode;\n        key === 32 && e[preventDefault]();\n      },\n      toggle = function(e) {\n        var label = e[target].tagName === LABEL ? e[target] : e[target][parentNode].tagName === LABEL ? e[target][parentNode] : null; // the .btn label\n        \n        if ( !label ) return; //react if a label or its immediate child is clicked\n  \n        var eventTarget = e[target], // the button itself, the target of the handler function\n          labels = getElementsByClassName(eventTarget[parentNode],'btn'), // all the button group buttons\n          input = label[getElementsByTagName](INPUT)[0];\n  \n        if ( !input ) return; //return if no input found\n  \n        // manage the dom manipulation\n        if ( input.type === 'checkbox' ) { //checkboxes\n          if ( !input[checked] ) {\n            addClass(label,active);\n            input[getAttribute](checked);\n            input[setAttribute](checked,checked);\n            input[checked] = true;\n          } else {\n            removeClass(label,active);\n            input[getAttribute](checked);\n            input.removeAttribute(checked);\n            input[checked] = false;\n          }\n  \n          if (!toggled) { // prevent triggering the event twice\n            toggled = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n          }\n        }\n  \n        if ( input.type === 'radio' && !toggled ) { // radio buttons\n          if ( !input[checked] ) { // don't trigger if already active\n            addClass(label,active);\n            input[setAttribute](checked,checked);\n            input[checked] = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n  \n            toggled = true;\n            for (var i = 0, ll = labels[length]; i<ll; i++) {\n              var otherLabel = labels[i], otherInput = otherLabel[getElementsByTagName](INPUT)[0];\n              if ( otherLabel !== label && hasClass(otherLabel,active) )  {\n                removeClass(otherLabel,active);\n                otherInput.removeAttribute(checked);\n                otherInput[checked] = false;\n                bootstrapCustomEvent.call(otherInput, changeEvent, component); // trigger the change\n              }\n            }\n          }\n        }\n        setTimeout( function() { toggled = false; }, 50 );\n      };\n  \n    // init\n    if ( !( stringButton in element ) ) { // prevent adding event handlers twice\n      on( element, clickEvent, toggle );\n      queryElement('['+tabindex+']',element) && on( element, keyupEvent, keyHandler ), \n                                                on( element, keydownEvent, preventScroll );    \n    }\n  \n    // activate items on load\n    var labelsToACtivate = getElementsByClassName(element, 'btn'), lbll = labelsToACtivate[length];\n    for (var i=0; i<lbll; i++) {\n      !hasClass(labelsToACtivate[i],active) && queryElement('input:checked',labelsToACtivate[i]) \n                                            && addClass(labelsToACtivate[i],active);\n    }\n    element[stringButton] = this;\n  };\n  \n  // BUTTON DATA API\n  // =================\n  supports[push]( [ stringButton, Button, '['+dataToggle+'=\"buttons\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Carousel\n  ----------------------------------------------*/\n  \n  // CAROUSEL DEFINITION\n  // ===================\n  var Carousel = function( element, options ) {\n  \n    // initialization element\n    element = queryElement( element );\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var intervalAttribute = element[getAttribute](dataInterval),\n        intervalOption = options[interval],\n        intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute) || 5000,  // bootstrap carousel default interval\n        pauseData = element[getAttribute](dataPause) === hoverEvent || false,\n        keyboardData = element[getAttribute](dataKeyboard) === 'true' || false,\n      \n        // strings\n        component = 'carousel',\n        paused = 'paused',\n        direction = 'direction',\n        carouselItem = 'carousel-item',\n        dataSlideTo = 'data-slide-to'; \n  \n    this[keyboard] = options[keyboard] === true || keyboardData;\n    this[pause] = (options[pause] === hoverEvent || pauseData) ? hoverEvent : false; // false / hover\n  \n    this[interval] = typeof intervalOption === 'number' ? intervalOption\n                   : intervalData === 0 ? 0\n                   : intervalData;\n  \n    // bind, event targets\n    var self = this, index = element.index = 0, timer = element.timer = 0, \n      isSliding = false, // isSliding prevents click event handlers when animation is running\n      slides = getElementsByClassName(element,carouselItem), total = slides[length],\n      slideDirection = this[direction] = left,\n      leftArrow = getElementsByClassName(element,component+'-control-prev')[0], \n      rightArrow = getElementsByClassName(element,component+'-control-next')[0],\n      indicator = queryElement( '.'+component+'-indicators', element ),\n      indicators = indicator && indicator[getElementsByTagName]( \"LI\" ) || [];\n  \n    // handlers\n    var pauseHandler = function () {\n        if ( self[interval] !==false && !hasClass(element,paused) ) {\n          addClass(element,paused);\n          !isSliding && clearInterval( timer );\n        }\n      },\n      resumeHandler = function() {\n        if ( self[interval] !== false && hasClass(element,paused) ) {\n          removeClass(element,paused);\n          !isSliding && clearInterval( timer );\n          !isSliding && self.cycle();\n        }\n      },\n      indicatorHandler = function(e) {\n        e[preventDefault]();\n        if (isSliding) return;\n  \n        var eventTarget = e[target]; // event target | the current active item\n  \n        if ( eventTarget && !hasClass(eventTarget,active) && eventTarget[getAttribute](dataSlideTo) ) {\n          index = parseInt( eventTarget[getAttribute](dataSlideTo), 10 );\n        } else { return false; }\n  \n        self.slideTo( index ); //Do the slide\n      },\n      controlsHandler = function (e) {\n        e[preventDefault]();\n        if (isSliding) return;\n  \n        var eventTarget = e.currentTarget || e.srcElement;\n  \n        if ( eventTarget === rightArrow ) {\n          index++;\n        } else if ( eventTarget === leftArrow ) {\n          index--;\n        }\n  \n        self.slideTo( index ); //Do the slide\n      },\n      keyHandler = function (e) {\n        if (isSliding) return;\n        switch (e.which) {\n          case 39:\n            index++;\n            break;\n          case 37:\n            index--;\n            break;\n          default: return;\n        }\n        self.slideTo( index ); //Do the slide\n      },\n      // private methods\n      isElementInScrollRange = function () {\n        var rect = element[getBoundingClientRect](),\n          viewportHeight = globalObject[innerHeight] || HTML[clientHeight]\n        return rect[top] <= viewportHeight && rect[bottom] >= 0; // bottom && top\n      },    \n      setActivePage = function( pageIndex ) { //indicators\n        for ( var i = 0, icl = indicators[length]; i < icl; i++ ) {\n          removeClass(indicators[i],active);\n        }\n        if (indicators[pageIndex]) addClass(indicators[pageIndex], active);\n      };\n  \n  \n    // public methods\n    this.cycle = function() {\n      timer = setInterval(function() {\n        isElementInScrollRange() && (index++, self.slideTo( index ) );\n      }, this[interval]);\n    };\n    this.slideTo = function( next ) {\n      if (isSliding) return; // when controled via methods, make sure to check again      \n      \n      var activeItem = this.getActiveIndex(), // the current active\n          orientation;\n      \n      // determine slideDirection first\n      if  ( (activeItem < next ) || (activeItem === 0 && next === total -1 ) ) {\n        slideDirection = self[direction] = left; // next\n      } else if  ( (activeItem > next) || (activeItem === total - 1 && next === 0 ) ) {\n        slideDirection = self[direction] = right; // prev\n      }\n  \n      // find the right next index \n      if ( next < 0 ) { next = total - 1; } \n      else if ( next === total ){ next = 0; }\n  \n      // update index\n      index = next;\n  \n      orientation = slideDirection === left ? 'next' : 'prev'; //determine type\n      bootstrapCustomEvent.call(element, slideEvent, component, slides[next]); // here we go with the slide\n  \n      isSliding = true;\n      clearInterval(timer);\n      setActivePage( next );\n  \n      if ( supportTransitions && hasClass(element,'slide') ) {\n  \n        addClass(slides[next],carouselItem +'-'+ orientation);\n        slides[next][offsetWidth];\n        addClass(slides[next],carouselItem +'-'+ slideDirection);\n        addClass(slides[activeItem],carouselItem +'-'+ slideDirection);\n  \n        one(slides[activeItem], transitionEndEvent, function(e) {\n          var timeout = e[target] !== slides[activeItem] ? e.elapsedTime*1000 : 0;\n          \n          setTimeout(function(){\n            isSliding = false;\n  \n            addClass(slides[next],active);\n            removeClass(slides[activeItem],active);\n  \n            removeClass(slides[next],carouselItem +'-'+ orientation);\n            removeClass(slides[next],carouselItem +'-'+ slideDirection);\n            removeClass(slides[activeItem],carouselItem +'-'+ slideDirection);\n  \n            bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n  \n            if ( !DOC.hidden && self[interval] && !hasClass(element,paused) ) {\n              self.cycle();\n            }\n          },timeout+100);\n        });\n  \n      } else {\n        addClass(slides[next],active);\n        slides[next][offsetWidth];\n        removeClass(slides[activeItem],active);\n        setTimeout(function() {\n          isSliding = false;\n          if ( self[interval] && !hasClass(element,paused) ) {\n            self.cycle();\n          }\n          bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n        }, 100 );\n      }\n    };\n    this.getActiveIndex = function () {\n      return slides[indexOf](getElementsByClassName(element,carouselItem+' active')[0]) || 0;\n    };\n  \n    // init\n    if ( !(stringCarousel in element ) ) { // prevent adding event handlers twice\n  \n      if ( self[pause] && self[interval] ) {\n        on( element, mouseHover[0], pauseHandler );\n        on( element, mouseHover[1], resumeHandler );\n        on( element, 'touchstart', pauseHandler );\n        on( element, 'touchend', resumeHandler );\n      }\n    \n      rightArrow && on( rightArrow, clickEvent, controlsHandler );\n      leftArrow && on( leftArrow, clickEvent, controlsHandler );\n    \n      indicator && on( indicator, clickEvent, indicatorHandler );\n      self[keyboard] === true && on( globalObject, keydownEvent, keyHandler );\n    }\n    if (self.getActiveIndex()<0) {\n      slides[length] && addClass(slides[0],active);\n      indicators[length] && setActivePage(0);\n    }\n  \n    if ( self[interval] ){ self.cycle(); }\n    element[stringCarousel] = self;\n  };\n  \n  // CAROUSEL DATA API\n  // =================\n  supports[push]( [ stringCarousel, Carousel, '['+dataRide+'=\"carousel\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Collapse\n  -----------------------------------------------*/\n  \n  // COLLAPSE DEFINITION\n  // ===================\n  var Collapse = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // event targets and constants\n    var accordion = null, collapse = null, self = this, \n      isAnimating = false, // when true it will prevent click handlers\n      accordionData = element[getAttribute]('data-parent'),\n  \n      // component strings\n      component = 'collapse',\n      collapsed = 'collapsed',\n  \n      // private methods\n      openAction = function(collapseElement,toggle) {\n        bootstrapCustomEvent.call(collapseElement, showEvent, component);\n        isAnimating = true;\n        addClass(collapseElement,collapsing);\n        removeClass(collapseElement,component);\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px';\n        \n        emulateTransitionEnd(collapseElement, function() {\n          isAnimating = false;\n          collapseElement[setAttribute](ariaExpanded,'true');\n          toggle[setAttribute](ariaExpanded,'true');\n          removeClass(collapseElement,collapsing);\n          addClass(collapseElement, component);\n          addClass(collapseElement,showClass);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, shownEvent, component);\n        });\n      },\n      closeAction = function(collapseElement,toggle) {\n        bootstrapCustomEvent.call(collapseElement, hideEvent, component);\n        isAnimating = true;\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px'; // set height first\n        removeClass(collapseElement,component);\n        removeClass(collapseElement,showClass);\n        addClass(collapseElement,collapsing);\n        collapseElement[offsetWidth]; // force reflow to enable transition\n        collapseElement[style][height] = '0px';\n        \n        emulateTransitionEnd(collapseElement, function() {\n          isAnimating = false;\n          collapseElement[setAttribute](ariaExpanded,'false');\n          toggle[setAttribute](ariaExpanded,'false');\n          removeClass(collapseElement,collapsing);\n          addClass(collapseElement,component);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, hiddenEvent, component);\n        });\n      },\n      getTarget = function() {\n        var href = element.href && element[getAttribute]('href'),\n          parent = element[getAttribute](dataTarget),\n          id = href || ( parent && parent.charAt(0) === '#' ) && parent;\n        return id && queryElement(id);\n      };\n    \n    // public methods\n    this.toggle = function(e) {\n      e[preventDefault]();\n      if (isAnimating) return;\n      if (!hasClass(collapse,showClass)) { self.show(); } \n      else { self.hide(); }\n    };\n    this.hide = function() {\n      closeAction(collapse,element);\n      addClass(element,collapsed);\n    };\n    this.show = function() {\n      if ( accordion ) {\n        var activeCollapse = queryElement('.'+component+'.'+showClass,accordion),\n            toggle = activeCollapse && (queryElement('['+dataToggle+'=\"'+component+'\"]['+dataTarget+'=\"#'+activeCollapse.id+'\"]',accordion)\n                   || queryElement('['+dataToggle+'=\"'+component+'\"][href=\"#'+activeCollapse.id+'\"]',accordion) ),\n            correspondingCollapse = toggle && (toggle[getAttribute](dataTarget) || toggle.href);\n        if ( activeCollapse && toggle && activeCollapse !== collapse ) {\n          closeAction(activeCollapse,toggle); \n          if ( correspondingCollapse.split('#')[1] !== collapse.id ) { addClass(toggle,collapsed); } \n          else { removeClass(toggle,collapsed); }\n        }\n      }\n  \n      openAction(collapse,element);\n      removeClass(element,collapsed);\n    };\n  \n    // init\n    if ( !(stringCollapse in element ) ) { // prevent adding event handlers twice\n      on(element, clickEvent, self.toggle);\n    }\n    collapse = getTarget();\n    accordion = queryElement(options.parent) || accordionData && getClosest(element, accordionData);\n    element[stringCollapse] = self;\n  };\n  \n  // COLLAPSE DATA API\n  // =================\n  supports[push]( [ stringCollapse, Collapse, '['+dataToggle+'=\"collapse\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Dropdown\n  ----------------------------------------------*/\n  \n  // DROPDOWN DEFINITION\n  // ===================\n  var Dropdown = function( element, option ) {\n      \n    // initialization element\n    element = queryElement(element);\n  \n    // set option\n    this.persist = option === true || element[getAttribute]('data-persist') === 'true' || false;\n  \n    // constants, event targets, strings\n    var self = this, children = 'children',\n      parent = element[parentNode],\n      component = 'dropdown', open = 'open',\n      relatedTarget = null,\n      menu = queryElement('.dropdown-menu', parent),\n      menuItems = (function(){\n        var set = menu[children], newSet = [];\n        for ( var i=0; i<set[length]; i++ ){\n          set[i][children][length] && (set[i][children][0].tagName === 'A' && newSet[push](set[i][children][0]));\n          set[i].tagName === 'A' && newSet[push](set[i]);\n        }\n        return newSet;\n      })(),\n  \n      // preventDefault on empty anchor links\n      preventEmptyAnchor = function(anchor){\n        (anchor.href && anchor.href.slice(-1) === '#' || anchor[parentNode] && anchor[parentNode].href \n          && anchor[parentNode].href.slice(-1) === '#') && this[preventDefault]();    \n      },\n  \n      // toggle dismissible events\n      toggleDismiss = function(){\n        var type = element[open] ? on : off;\n        type(DOC, clickEvent, dismissHandler); \n        type(DOC, keydownEvent, preventScroll);\n        type(DOC, keyupEvent, keyHandler);\n      },\n  \n      // handlers\n      dismissHandler = function(e) {\n        var eventTarget = e[target], hasData = eventTarget && (stringDropdown in eventTarget || stringDropdown in eventTarget[parentNode]);\n        if ( (eventTarget === menu || menu[contains](eventTarget)) && (self.persist || hasData) ) { return; }\n        else {\n          relatedTarget = eventTarget === element || element[contains](eventTarget) ? element : null;\n          hide();\n        }\n        preventEmptyAnchor.call(e,eventTarget);\n      },\n      clickHandler = function(e) {\n        relatedTarget = element;\n        show();\n        preventEmptyAnchor.call(e,e[target]);\n      },\n      preventScroll = function(e){\n        var key = e.which || e.keyCode;\n        if( key === 38 || key === 40 ) { e[preventDefault](); }\n      },\n      keyHandler = function(e){\n        var key = e.which || e.keyCode,\n          activeItem = DOC.activeElement,\n          idx = menuItems[indexOf](activeItem),\n          isSameElement = activeItem === element,\n          isInsideMenu = menu[contains](activeItem),\n          isMenuItem = activeItem[parentNode] === menu || activeItem[parentNode][parentNode] === menu;          \n  \n        if ( isMenuItem || isSameElement ) { // navigate up | down\n          idx = isSameElement ? 0 \n                              : key === 38 ? (idx>1?idx-1:0)\n                              : key === 40 ? (idx<menuItems[length]-1?idx+1:idx) : idx;\n          menuItems[idx] && setFocus(menuItems[idx]);\n        }\n        if ( (menuItems[length] && isMenuItem // menu has items\n              || !menuItems[length] && (isInsideMenu || isSameElement)  // menu might be a form\n              || !isInsideMenu ) // or the focused element is not in the menu at all\n              && element[open] && key === 27  // menu must be open\n        ) {\n          self.toggle();\n          relatedTarget = null;\n        }\n      },\n  \n      // private methods\n      show = function() {\n        bootstrapCustomEvent.call(parent, showEvent, component, relatedTarget);\n        addClass(menu,showClass);\n        addClass(parent,showClass);\n        menu[setAttribute](ariaExpanded,true);\n        bootstrapCustomEvent.call(parent, shownEvent, component, relatedTarget);\n        element[open] = true;\n        off(element, clickEvent, clickHandler);\n        setTimeout(function(){\n          setFocus( menu[getElementsByTagName]('INPUT')[0] || element ); // focus the first input item | element\n          toggleDismiss();\n        },1);\n      },\n      hide = function() {\n        bootstrapCustomEvent.call(parent, hideEvent, component, relatedTarget);\n        removeClass(menu,showClass);\n        removeClass(parent,showClass);\n        menu[setAttribute](ariaExpanded,false);\n        bootstrapCustomEvent.call(parent, hiddenEvent, component, relatedTarget);\n        element[open] = false;\n        toggleDismiss();\n        setFocus(element);\n        setTimeout(function(){ on(element, clickEvent, clickHandler); },1);\n      };\n  \n    // set initial state to closed\n    element[open] = false;\n  \n    // public methods\n    this.toggle = function() {\n      if (hasClass(parent,showClass) && element[open]) { hide(); } \n      else { show(); }\n    };\n  \n    // init\n    if ( !(stringDropdown in element) ) { // prevent adding event handlers twice\n      !tabindex in menu && menu[setAttribute](tabindex, '0'); // Fix onblur on Chrome | Safari\n      on(element, clickEvent, clickHandler);\n    }\n  \n    element[stringDropdown] = self;\n  };\n  \n  // DROPDOWN DATA API\n  // =================\n  supports[push]( [stringDropdown, Dropdown, '['+dataToggle+'=\"dropdown\"]'] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Modal\n  -------------------------------------------*/\n  \n  // MODAL DEFINITION\n  // ===============\n  var Modal = function(element, options) { // element can be the modal/triggering button\n  \n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = queryElement(element);\n  \n    // determine modal, triggering element\n    var btnCheck = element[getAttribute](dataTarget)||element[getAttribute]('href'),\n      checkModal = queryElement( btnCheck ),\n      modal = hasClass(element,'modal') ? element : checkModal,\n  \n      // strings\n      component = 'modal',\n      staticString = 'static',\n      paddingLeft = 'paddingLeft',\n      paddingRight = 'paddingRight',\n      modalBackdropString = 'modal-backdrop';\n  \n    if ( hasClass(element,'modal') ) { element = null; } // modal is now independent of it's triggering element\n  \n    if ( !modal ) { return; } // invalidate\n  \n    // set options\n    options = options || {};\n  \n    this[keyboard] = options[keyboard] === false || modal[getAttribute](dataKeyboard) === 'false' ? false : true;\n    this[backdrop] = options[backdrop] === staticString || modal[getAttribute](databackdrop) === staticString ? staticString : true;\n    this[backdrop] = options[backdrop] === false || modal[getAttribute](databackdrop) === 'false' ? false : this[backdrop];\n    this[content]  = options[content]; // JavaScript only\n  \n    // bind, constants, event targets and other vars\n    var self = this, relatedTarget = null,\n      bodyIsOverflowing, modalIsOverflowing, scrollbarWidth, overlay,\n  \n      // also find fixed-top / fixed-bottom items\n      fixedItems = getElementsByClassName(HTML,fixedTop).concat(getElementsByClassName(HTML,fixedBottom)),\n  \n      // private methods\n      getWindowWidth = function() {\n        var htmlRect = HTML[getBoundingClientRect]();\n        return globalObject[innerWidth] || (htmlRect[right] - Math.abs(htmlRect[left]));\n      },\n      setScrollbar = function () {\n        var bodyStyle = globalObject.getComputedStyle(DOC[body]),\n            bodyPad = parseInt((bodyStyle[paddingRight]), 10), itemPad;\n        if (bodyIsOverflowing) {\n          DOC[body][style][paddingRight] = (bodyPad + scrollbarWidth) + 'px';\n          if (fixedItems[length]){\n            for (var i = 0; i < fixedItems[length]; i++) {\n              itemPad = globalObject.getComputedStyle(fixedItems[i])[paddingRight];\n              fixedItems[i][style][paddingRight] = ( parseInt(itemPad) + scrollbarWidth) + 'px';\n            }\n          }\n        }\n      },\n      resetScrollbar = function () {\n        DOC[body][style][paddingRight] = '';\n        if (fixedItems[length]){\n          for (var i = 0; i < fixedItems[length]; i++) {\n            fixedItems[i][style][paddingRight] = '';\n          }\n        }\n      },\n      measureScrollbar = function () { // thx walsh\n        var scrollDiv = DOC[createElement]('div'), scrollBarWidth;\n        scrollDiv.className = component+'-scrollbar-measure'; // this is here to stay\n        DOC[body][appendChild](scrollDiv);\n        scrollBarWidth = scrollDiv[offsetWidth] - scrollDiv[clientWidth];\n        DOC[body].removeChild(scrollDiv);\n        return scrollBarWidth;\n      },\n      checkScrollbar = function () {\n        bodyIsOverflowing = DOC[body][clientWidth] < getWindowWidth();\n        modalIsOverflowing = modal[scrollHeight] > HTML[clientHeight];\n        scrollbarWidth = measureScrollbar();\n      },\n      adjustDialog = function () {\n        modal[style][paddingLeft] = !bodyIsOverflowing && modalIsOverflowing ? scrollbarWidth + 'px' : '';\n        modal[style][paddingRight] = bodyIsOverflowing && !modalIsOverflowing ? scrollbarWidth + 'px' : '';\n      },\n      resetAdjustments = function () {\n        modal[style][paddingLeft] = '';\n        modal[style][paddingRight] = '';\n      },\n      createOverlay = function() {\n        modalOverlay = 1;        \n        \n        var newOverlay = DOC[createElement]('div');\n        overlay = queryElement('.'+modalBackdropString);\n  \n        if ( overlay === null ) {\n          newOverlay[setAttribute]('class',modalBackdropString+' fade');\n          overlay = newOverlay;\n          DOC[body][appendChild](overlay);\n        }\n      },\n      removeOverlay = function() {\n        overlay = queryElement('.'+modalBackdropString);\n        if ( overlay && overlay !== null && typeof overlay === 'object' ) {\n          modalOverlay = 0;        \n          DOC[body].removeChild(overlay); overlay = null;\n        }\n        bootstrapCustomEvent.call(modal, hiddenEvent, component);      \n      },\n      keydownHandlerToggle = function() {\n        if (hasClass(modal,showClass)) {\n          on(DOC, keydownEvent, keyHandler);\n        } else {\n          off(DOC, keydownEvent, keyHandler);\n        }\n      },\n      resizeHandlerToggle = function() {\n        if (hasClass(modal,showClass)) {\n          on(globalObject, resizeEvent, self.update);\n        } else {\n          off(globalObject, resizeEvent, self.update);\n        }\n      },\n      dismissHandlerToggle = function() {\n        if (hasClass(modal,showClass)) {\n          on(modal, clickEvent, dismissHandler);\n        } else {\n          off(modal, clickEvent, dismissHandler);\n        }\n      },\n      // triggers\n      triggerShow = function() {\n        setFocus(modal);\n        bootstrapCustomEvent.call(modal, shownEvent, component, relatedTarget);\n      },\n      triggerHide = function() {\n        modal[style].display = '';\n        element && (setFocus(element));\n        \n        (function(){\n          if (!getElementsByClassName(DOC,component+' '+showClass)[0]) {\n            resetAdjustments();\n            resetScrollbar();\n            removeClass(DOC[body],component+'-open');\n            overlay && hasClass(overlay,'fade') ? (removeClass(overlay,showClass), emulateTransitionEnd(overlay,removeOverlay)) \n            : removeOverlay();\n  \n            resizeHandlerToggle();\n            dismissHandlerToggle();\n            keydownHandlerToggle();\n          }\n        }());\n      },\n      // handlers\n      clickHandler = function(e) {\n        var clickTarget = e[target];\n        clickTarget = clickTarget[hasAttribute](dataTarget) || clickTarget[hasAttribute]('href') ? clickTarget : clickTarget[parentNode];\n        if ( clickTarget === element && !hasClass(modal,showClass) ) {\n          modal.modalTrigger = element;\n          relatedTarget = element;\n          self.show();\n          e[preventDefault]();\n        }\n      },\n      keyHandler = function(e) {\n        if (self[keyboard] && e.which == 27 && hasClass(modal,showClass)) {\n          self.hide();\n        }\n      },\n      dismissHandler = function(e) {\n        var clickTarget = e[target];\n        if ( hasClass(modal,showClass) && (clickTarget[parentNode][getAttribute](dataDismiss) === component\n            || clickTarget[getAttribute](dataDismiss) === component\n            || (clickTarget === modal && self[backdrop] !== staticString) ) ) {\n          self.hide(); relatedTarget = null;\n          e[preventDefault]();\n        }\n      };\n  \n    // public methods\n    this.toggle = function() {\n      if ( hasClass(modal,showClass) ) {this.hide();} else {this.show();}\n    };\n    this.show = function() {\n      bootstrapCustomEvent.call(modal, showEvent, component, relatedTarget);\n  \n      // we elegantly hide any opened modal\n      var currentOpen = getElementsByClassName(DOC,component+' '+showClass)[0];\n      currentOpen && currentOpen !== modal && currentOpen.modalTrigger[stringModal].hide();\n  \n      if ( this[backdrop] ) {\n        !modalOverlay && createOverlay();\n      }\n  \n      if ( overlay && modalOverlay && !hasClass(overlay,showClass)) {\n        overlay[offsetWidth]; // force reflow to enable trasition\n        addClass(overlay, showClass);\n      }\n  \n      setTimeout( function() {\n        modal[style].display = 'block';\n  \n        checkScrollbar();\n        setScrollbar();\n        adjustDialog();\n  \n        addClass(DOC[body],component+'-open');\n        addClass(modal,showClass);\n        modal[setAttribute](ariaHidden, false);\n        \n        resizeHandlerToggle();\n        dismissHandlerToggle();\n        keydownHandlerToggle();\n  \n        hasClass(modal,'fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();\n      }, supportTransitions ? 150 : 0);\n    };\n    this.hide = function() {\n      bootstrapCustomEvent.call(modal, hideEvent, component);\n      overlay = queryElement('.'+modalBackdropString);\n  \n      removeClass(modal,showClass);\n      modal[setAttribute](ariaHidden, true);\n  \n      (function(){\n        hasClass(modal,'fade') ? emulateTransitionEnd(modal, triggerHide) : triggerHide();\n      }());\n    };\n    this.setContent = function( content ) {\n      queryElement('.'+component+'-content',modal)[innerHTML] = content;\n    };\n    this.update = function() {\n      if (hasClass(modal,showClass)) {\n        checkScrollbar();\n        setScrollbar();\n        adjustDialog();\n      }\n    };\n  \n    // init\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n    if ( !!element && !(stringModal in element) ) {\n      on(element, clickEvent, clickHandler);\n    }\n    if ( !!self[content] ) { self.setContent( self[content] ); }\n    !!element && (element[stringModal] = self);\n  };\n  \n  // DATA API\n  supports[push]( [ stringModal, Modal, '['+dataToggle+'=\"modal\"]' ] );\n  \n  /* Native Javascript for Bootstrap 4 | Popover\n  ----------------------------------------------*/\n  \n  // POPOVER DEFINITION\n  // ==================\n  var Popover = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var triggerData = element[getAttribute](dataTrigger), // click / hover / focus\n        animationData = element[getAttribute](dataAnimation), // true / false\n        placementData = element[getAttribute](dataPlacement),\n        dismissibleData = element[getAttribute](dataDismissible),\n        delayData = element[getAttribute](dataDelay),\n        containerData = element[getAttribute](dataContainer),\n  \n        // internal strings\n        component = 'popover',\n        template = 'template',\n        trigger = 'trigger',\n        classString = 'class',\n        div = 'div',\n        fade = 'fade',\n        content = 'content',\n        dataContent = 'data-content',\n        dismissible = 'dismissible',\n        closeBtn = '<button type=\"button\" class=\"close\">Ã</button>',\n  \n        // check container\n        containerElement = queryElement(options[container]),\n        containerDataElement = queryElement(containerData),       \n        \n        // maybe the element is inside a modal\n        modal = getClosest(element,'.modal'),\n        \n        // maybe the element is inside a fixed navbar\n        navbarFixedTop = getClosest(element,'.'+fixedTop),\n        navbarFixedBottom = getClosest(element,'.'+fixedBottom);\n  \n    // set instance options\n    this[template] = options[template] ? options[template] : null; // JavaScript only\n    this[trigger] = options[trigger] ? options[trigger] : triggerData || hoverEvent;\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[dismissible] = options[dismissible] || dismissibleData === 'true' ? true : false;\n    this[container] = containerElement ? containerElement \n                    : containerDataElement ? containerDataElement \n                    : navbarFixedTop ? navbarFixedTop\n                    : navbarFixedBottom ? navbarFixedBottom\n                    : modal ? modal : DOC[body];\n    \n    // bind, content\n    var self = this, \n      titleString = element[getAttribute](dataTitle) || null,\n      contentString = element[getAttribute](dataContent) || null;\n  \n    if ( !contentString && !this[template] ) return; // invalidate\n  \n    // constants, vars\n    var popover = null, timer = 0, placementSetting = this[placement],\n      \n      // handlers\n      dismissibleHandler = function(e) {\n        if (popover !== null && e[target] === queryElement('.close',popover)) {\n          self.hide();\n        }\n      },\n  \n      // private methods\n      removePopover = function() {\n        self[container].removeChild(popover);\n        timer = null; popover = null; \n      },\n      createPopover = function() {\n        titleString = element[getAttribute](dataTitle); // check content again\n        contentString = element[getAttribute](dataContent);\n  \n        popover = DOC[createElement](div);\n  \n        // popover arrow\n        var popoverArrow = DOC[createElement](div);\n        popoverArrow[setAttribute](classString,'arrow');\n        popover[appendChild](popoverArrow);\n  \n        if ( contentString !== null && self[template] === null ) { //create the popover from data attributes\n  \n          popover[setAttribute]('role','tooltip');\n  \n          if (titleString !== null) {\n            var popoverTitle = DOC[createElement]('h3');\n            popoverTitle[setAttribute](classString,component+'-header');\n  \n            popoverTitle[innerHTML] = self[dismissible] ? titleString + closeBtn : titleString;\n            popover[appendChild](popoverTitle);\n          }\n  \n          //set popover content\n          var popoverContent = DOC[createElement](div);\n          popoverContent[setAttribute](classString,component+'-body');\n          popoverContent[innerHTML] = self[dismissible] && titleString === null ? contentString + closeBtn : contentString;\n          popover[appendChild](popoverContent);\n  \n        } else {  // or create the popover from template\n          var popoverTemplate = DOC[createElement](div);\n          popoverTemplate[innerHTML] = self[template];\n          popover[innerHTML] = popoverTemplate.firstChild[innerHTML];\n        }\n  \n        //append to the container\n        self[container][appendChild](popover);\n        popover[style].display = 'block';\n        popover[setAttribute](classString, component+ ' bs-' + component+'-'+placementSetting + ' ' + self[animation]);\n      },\n      showPopover = function () {\n        !hasClass(popover,showClass) && ( addClass(popover,showClass) );\n      },\n      updatePopover = function() {\n        styleTip(element,popover,placementSetting,self[container]);\n      },\n  \n      // event toggle\n      dismissHandlerToggle = function(type){\n        if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n          !self[dismissible] && type( element, 'blur', self.hide );\n        }\n        self[dismissible] && type( DOC, clickEvent, dismissibleHandler );     \n        type( globalObject, resizeEvent, self.hide );\n      },\n  \n      // triggers\n      showTrigger = function() {\n        dismissHandlerToggle(on);\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function() {\n        dismissHandlerToggle(off);\n        removePopover();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n  \n    // public methods / handlers\n    this.toggle = function() {\n      if (popover === null) { self.show(); } \n      else { self.hide(); }\n    };\n    this.show = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (popover === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          createPopover();\n          updatePopover();\n          showPopover();\n          bootstrapCustomEvent.call(element, showEvent, component);\n          !!self[animation] ? emulateTransitionEnd(popover, showTrigger) : showTrigger();\n        }\n      }, 20 );\n    };\n    this.hide = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (popover && popover !== null && hasClass(popover,showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(popover,showClass);\n          !!self[animation] ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();\n        }\n      }, self[delay] );\n    };\n  \n    // init\n    if ( !(stringPopover in element) ) { // prevent adding event handlers twice\n      if (self[trigger] === hoverEvent) {\n        on( element, mouseHover[0], self.show );\n        if (!self[dismissible]) { on( element, mouseHover[1], self.hide ); }\n      } else if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n        on( element, self[trigger], self.toggle );\n      }\n    }\n    element[stringPopover] = self;\n  };\n  \n  // POPOVER DATA API\n  // ================\n  supports[push]( [ stringPopover, Popover, '['+dataToggle+'=\"popover\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | ScrollSpy\n  -----------------------------------------------*/\n  \n  // SCROLLSPY DEFINITION\n  // ====================\n  var ScrollSpy = function(element, options) {\n  \n    // initialization element, the element we spy on\n    element = queryElement(element); \n  \n    // DATA API\n    var targetData = queryElement(element[getAttribute](dataTarget)),\n        offsetData = element[getAttribute]('data-offset');\n  \n    // set options\n    options = options || {};\n    if ( !options[target] && !targetData ) { return; } // invalidate\n  \n    // event targets, constants\n    var self = this, spyTarget = options[target] && queryElement(options[target]) || targetData,\n        links = spyTarget && spyTarget[getElementsByTagName]('A'),\n        offset = parseInt(offsetData || options['offset']) || 10,      \n        items = [], targetItems = [], scrollOffset,\n        scrollTarget = element[offsetHeight] < element[scrollHeight] ? element : globalObject, // determine which is the real scrollTarget\n        isWindow = scrollTarget === globalObject;  \n  \n    // populate items and targets\n    for (var i=0, il=links[length]; i<il; i++) {\n      var href = links[i][getAttribute]('href'), \n          targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);\n      if ( !!targetItem ) {\n        items[push](links[i]);\n        targetItems[push](targetItem);\n      }\n    }\n  \n    // private methods\n    var updateItem = function(index) {\n        var item = items[index],\n          targetItem = targetItems[index], // the menu item targets this element\n          dropdown = item[parentNode][parentNode],\n          dropdownLink = hasClass(dropdown,'dropdown') && dropdown[getElementsByTagName]('A')[0],\n          targetRect = isWindow && targetItem[getBoundingClientRect](),\n  \n          isActive = hasClass(item,active) || false,\n  \n          topEdge = (isWindow ? targetRect[top] + scrollOffset : targetItem[offsetTop]) - offset,\n          bottomEdge = isWindow ? targetRect[bottom] + scrollOffset - offset : targetItems[index+1] ? targetItems[index+1][offsetTop] - offset : element[scrollHeight],\n  \n          inside = scrollOffset >= topEdge && bottomEdge > scrollOffset;\n  \n        if ( !isActive && inside ) {\n          if ( !hasClass(item,active) ) {\n            addClass(item,active);\n            if (dropdownLink && !hasClass(dropdownLink,active) ) {\n              addClass(dropdownLink,active);\n            }\n            bootstrapCustomEvent.call(element, 'activate', 'scrollspy', items[index]);\n          }\n        } else if ( !inside ) {\n          if ( hasClass(item,active) ) {\n            removeClass(item,active);\n            if (dropdownLink && hasClass(dropdownLink,active) && !getElementsByClassName(item[parentNode],active).length  ) {\n              removeClass(dropdownLink,active);\n            }\n          }\n        } else if ( !inside && !isActive || isActive && inside ) {\n          return;\n        }\n      },\n      updateItems = function(){\n        scrollOffset = isWindow ? getScroll().y : element[scrollTop];\n        for (var index=0, itl=items[length]; index<itl; index++) {\n          updateItem(index)\n        }\n      };\n  \n    // public method\n    this.refresh = function () {\n      updateItems();\n    }\n  \n    // init\n    if ( !(stringScrollSpy in element) ) { // prevent adding event handlers twice\n      on( scrollTarget, scrollEvent, self.refresh );\n      on( globalObject, resizeEvent, self.refresh ); \n    }\n    self.refresh();\n    element[stringScrollSpy] = self;\n  };\n  \n  // SCROLLSPY DATA API\n  // ==================\n  supports[push]( [ stringScrollSpy, ScrollSpy, '['+dataSpy+'=\"scroll\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Tab\n  -----------------------------------------*/\n  \n  // TAB DEFINITION\n  // ==============\n  var Tab = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // DATA API\n    var heightData = element[getAttribute](dataHeight),\n      \n        // strings\n        component = 'tab', height = 'height', float = 'float', isAnimating = 'isAnimating';\n        \n    // set options\n    options = options || {};\n    this[height] = supportTransitions ? (options[height] || heightData === 'true') : false;\n  \n    // bind, event targets\n    var self = this, next,\n      tabs = getClosest(element,'.nav'),\n      tabsContentContainer = false,\n      dropdown = tabs && queryElement('.dropdown-toggle',tabs),\n      activeTab, activeContent, nextContent, containerHeight, equalContents, nextHeight,\n      \n      // trigger\n      triggerEnd = function(){\n        tabsContentContainer[style][height] = '';\n        removeClass(tabsContentContainer,collapsing);\n        tabs[isAnimating] = false;\n      },\n      triggerShow = function() {\n        if (tabsContentContainer) { // height animation\n          if ( equalContents ) {\n            triggerEnd();\n          } else {\n            setTimeout(function(){ // enables height animation\n              tabsContentContainer[style][height] = nextHeight + 'px'; // height animation\n              tabsContentContainer[offsetWidth];\n              emulateTransitionEnd(tabsContentContainer, triggerEnd);\n            },1);\n          }\n        } else {\n          tabs[isAnimating] = false; \n        }\n        bootstrapCustomEvent.call(next, shownEvent, component, activeTab);\n      },\n      triggerHide = function() {\n        if (tabsContentContainer) {\n          activeContent[style][float] = left;\n          nextContent[style][float] = left;        \n          containerHeight = activeContent[scrollHeight];\n        }\n          \n        addClass(nextContent,active);\n        bootstrapCustomEvent.call(next, showEvent, component, activeTab);\n  \n        removeClass(activeContent,active);\n        bootstrapCustomEvent.call(activeTab, hiddenEvent, component, next);\n        \n        if (tabsContentContainer) {\n          nextHeight = nextContent[scrollHeight];\n          equalContents = nextHeight === containerHeight;\n          addClass(tabsContentContainer,collapsing);\n          tabsContentContainer[style][height] = containerHeight + 'px'; // height animation\n          tabsContentContainer[offsetHeight];\n          activeContent[style][float] = '';\n          nextContent[style][float] = '';   \n        }\n  \n        if ( hasClass(nextContent, 'fade') ) {\n          setTimeout(function(){\n            addClass(nextContent,showClass);\n            emulateTransitionEnd(nextContent,triggerShow);\n          },20);\n        } else { triggerShow(); }        \n      };\n  \n    if (!tabs) return; // invalidate\n  \n    // set default animation state\n    tabs[isAnimating] = false;    \n          \n    // private methods\n    var getActiveTab = function() {\n        var activeTabs = getElementsByClassName(tabs,active), activeTab;\n        if ( activeTabs[length] === 1 && !hasClass(activeTabs[0][parentNode],'dropdown') ) {\n          activeTab = activeTabs[0];\n        } else if ( activeTabs[length] > 1 ) {\n          activeTab = activeTabs[activeTabs[length]-1];\n        }\n        return activeTab;\n      },\n      getActiveContent = function() {\n        return queryElement(getActiveTab()[getAttribute]('href'));\n      },\n      // handler \n      clickHandler = function(e) {\n        var href = e[target][getAttribute]('href');\n        e[preventDefault]();\n        next = e[target][getAttribute](dataToggle) === component || (href && href.charAt(0) === '#')\n             ? e[target] : e[target][parentNode]; // allow for child elements like icons to use the handler\n        !tabs[isAnimating] && !hasClass(next,active) && self.show();\n      };\n  \n    // public method\n    this.show = function() { // the tab we clicked is now the next tab\n      next = next || element;\n      nextContent = queryElement(next[getAttribute]('href')); //this is the actual object, the next tab content to activate\n      activeTab = getActiveTab(); \n      activeContent = getActiveContent();\n      \n      tabs[isAnimating] = true;\n      removeClass(activeTab,active);\n      addClass(next,active);\n  \n      if ( dropdown ) {\n        if ( !hasClass(element[parentNode],'dropdown-menu') ) {\n          if (hasClass(dropdown,active)) removeClass(dropdown,active);\n        } else {\n          if (!hasClass(dropdown,active)) addClass(dropdown,active);\n        }\n      }\n      \n      bootstrapCustomEvent.call(activeTab, hideEvent, component, next);\n  \n      if (hasClass(activeContent, 'fade')) {\n        removeClass(activeContent,showClass);\n        emulateTransitionEnd(activeContent, triggerHide);\n      } else { triggerHide(); }\n    };\n  \n    // init\n    if ( !(stringTab in element) ) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    if (self[height]) { tabsContentContainer = getActiveContent()[parentNode]; }\n    element[stringTab] = self;\n  };\n  \n  // TAB DATA API\n  // ============\n  supports[push]( [ stringTab, Tab, '['+dataToggle+'=\"tab\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Tooltip\n  ---------------------------------------------*/\n  \n  // TOOLTIP DEFINITION\n  // ==================\n  var Tooltip = function( element,options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var animationData = element[getAttribute](dataAnimation),\n        placementData = element[getAttribute](dataPlacement),\n        delayData = element[getAttribute](dataDelay),\n        containerData = element[getAttribute](dataContainer),\n        \n        // strings\n        component = 'tooltip',\n        classString = 'class',\n        title = 'title',\n        fade = 'fade',\n        div = 'div',\n  \n        // check container\n        containerElement = queryElement(options[container]),\n        containerDataElement = queryElement(containerData),      \n  \n        // maybe the element is inside a modal\n        modal = getClosest(element,'.modal'),\n        \n        // maybe the element is inside a fixed navbar\n        navbarFixedTop = getClosest(element,'.'+fixedTop),\n        navbarFixedBottom = getClosest(element,'.'+fixedBottom);\n  \n    // set instance options\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[container] = containerElement ? containerElement \n                    : containerDataElement ? containerDataElement\n                    : navbarFixedTop ? navbarFixedTop\n                    : navbarFixedBottom ? navbarFixedBottom\n                    : modal ? modal : DOC[body];\n  \n    // bind, event targets, title and constants\n    var self = this, timer = 0, placementSetting = this[placement], tooltip = null,\n      titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle);\n  \n    if ( !titleString || titleString == \"\" ) return; // invalidate\n  \n    // private methods\n    var removeToolTip = function() {\n        self[container].removeChild(tooltip);\n        tooltip = null; timer = null;\n      },\n      createToolTip = function() {\n        titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle); // read the title again\n        if ( !titleString || titleString == \"\" ) return false; // invalidate\n        tooltip = DOC[createElement](div);\n        tooltip[setAttribute]('role',component);\n  \n        // tooltip arrow\n        var tooltipArrow = DOC[createElement](div);\n        tooltipArrow[setAttribute](classString,'arrow');\n        tooltip[appendChild](tooltipArrow);\n    \n        var tooltipInner = DOC[createElement](div);\n        tooltipInner[setAttribute](classString,component+'-inner');\n        tooltip[appendChild](tooltipInner);\n        tooltipInner[innerHTML] = titleString;\n  \n        self[container][appendChild](tooltip);\n        tooltip[setAttribute](classString, component + ' bs-' + component+'-'+placementSetting + ' ' + self[animation]);\n      },\n      updateTooltip = function () {\n        styleTip(element,tooltip,placementSetting,self[container]);\n      },\n      showTooltip = function () {\n        !hasClass(tooltip,showClass) && ( addClass(tooltip,showClass) );\n      },\n      // triggers\n      showTrigger = function() {\n        on( globalObject, resizeEvent, self.hide );\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function() {\n        off( globalObject, resizeEvent, self.hide );\n        removeToolTip();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n  \n    // public methods\n    this.show = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (tooltip === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          if(createToolTip() == false) return;\n          updateTooltip();\n          showTooltip();\n          bootstrapCustomEvent.call(element, showEvent, component);\n          !!self[animation] ? emulateTransitionEnd(tooltip, showTrigger) : showTrigger();\n        }\n      }, 20 );\n    };\n    this.hide = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (tooltip && hasClass(tooltip,showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(tooltip,showClass);\n          !!self[animation] ? emulateTransitionEnd(tooltip, hideTrigger) : hideTrigger();\n        }\n      }, self[delay]);\n    };\n    this.toggle = function() {\n      if (!tooltip) { self.show(); } \n      else { self.hide(); }\n    };\n  \n    // init\n    if ( !(stringTooltip in element) ) { // prevent adding event handlers twice\n      element[setAttribute](dataOriginalTitle,titleString);\n      element.removeAttribute(title);\n      on(element, mouseHover[0], self.show);\n      on(element, mouseHover[1], self.hide);\n    }\n    element[stringTooltip] = self;\n  };\n  \n  // TOOLTIP DATA API\n  // =================\n  supports[push]( [ stringTooltip, Tooltip, '['+dataToggle+'=\"tooltip\"]' ] );\n  \n  \n  \r\n  /* Native Javascript for Bootstrap 4 | Initialize Data API\r\n  --------------------------------------------------------*/\r\n  var initializeDataAPI = function( constructor, collection ){\r\n      for (var i=0, l=collection[length]; i<l; i++) {\r\n        new constructor(collection[i]);\r\n      }\r\n    },\r\n    initCallback = BSN.initCallback = function(lookUp){\r\n      lookUp = lookUp || DOC;\r\n      for (var i=0, l=supports[length]; i<l; i++) {\r\n        initializeDataAPI( supports[i][1], lookUp[querySelectorAll] (supports[i][2]) );\r\n      }\r\n    };\r\n  \r\n  // bulk initialize all components\r\n  DOC[body] ? initCallback() : on( DOC, 'DOMContentLoaded', function(){ initCallback(); } );\r\n  \n  return {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Tooltip: Tooltip\n  };\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS12NC5qcz82ZjhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB2Mi4wLjIyIHwgwqkgZG5wX3RoZW1lIHwgTUlULUxpY2Vuc2VcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EIHN1cHBvcnQ6XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIENvbW1vbkpTLWxpa2U6XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICB2YXIgYnNuID0gZmFjdG9yeSgpO1xuICAgIHJvb3QuQWxlcnQgPSBic24uQWxlcnQ7XG4gICAgcm9vdC5CdXR0b24gPSBic24uQnV0dG9uO1xuICAgIHJvb3QuQ2Fyb3VzZWwgPSBic24uQ2Fyb3VzZWw7XG4gICAgcm9vdC5Db2xsYXBzZSA9IGJzbi5Db2xsYXBzZTtcbiAgICByb290LkRyb3Bkb3duID0gYnNuLkRyb3Bkb3duO1xuICAgIHJvb3QuTW9kYWwgPSBic24uTW9kYWw7XG4gICAgcm9vdC5Qb3BvdmVyID0gYnNuLlBvcG92ZXI7XG4gICAgcm9vdC5TY3JvbGxTcHkgPSBic24uU2Nyb2xsU3B5O1xuICAgIHJvb3QuVGFiID0gYnNuLlRhYjtcbiAgICByb290LlRvb2x0aXAgPSBic24uVG9vbHRpcDtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBJbnRlcm5hbCBVdGlsaXR5IEZ1bmN0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIFxuICAvLyBnbG9iYWxzXG4gIHZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXN8fHdpbmRvdyxcbiAgICBET0MgPSBkb2N1bWVudCwgSFRNTCA9IERPQy5kb2N1bWVudEVsZW1lbnQsIGJvZHkgPSAnYm9keScsIC8vIGFsbG93IHRoZSBsaWJyYXJ5IHRvIGJlIHVzZWQgaW4gPGhlYWQ+XG4gIFxuICAgIC8vIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgR2xvYmFsIE9iamVjdFxuICAgIEJTTiA9IGdsb2JhbE9iamVjdC5CU04gPSB7fSxcbiAgICBzdXBwb3J0cyA9IEJTTi5zdXBwb3J0cyA9IFtdLFxuICBcbiAgICAvLyBmdW5jdGlvbiB0b2dnbGUgYXR0cmlidXRlc1xuICAgIGRhdGFUb2dnbGUgICAgPSAnZGF0YS10b2dnbGUnLFxuICAgIGRhdGFEaXNtaXNzICAgPSAnZGF0YS1kaXNtaXNzJyxcbiAgICBkYXRhU3B5ICAgICAgID0gJ2RhdGEtc3B5JyxcbiAgICBkYXRhUmlkZSAgICAgID0gJ2RhdGEtcmlkZScsXG4gIFxuICAgIC8vIGNvbXBvbmVudHNcbiAgICBzdHJpbmdBbGVydCAgICAgPSAnQWxlcnQnLFxuICAgIHN0cmluZ0J1dHRvbiAgICA9ICdCdXR0b24nLFxuICAgIHN0cmluZ0Nhcm91c2VsICA9ICdDYXJvdXNlbCcsXG4gICAgc3RyaW5nQ29sbGFwc2UgID0gJ0NvbGxhcHNlJyxcbiAgICBzdHJpbmdEcm9wZG93biAgPSAnRHJvcGRvd24nLFxuICAgIHN0cmluZ01vZGFsICAgICA9ICdNb2RhbCcsXG4gICAgc3RyaW5nUG9wb3ZlciAgID0gJ1BvcG92ZXInLFxuICAgIHN0cmluZ1Njcm9sbFNweSA9ICdTY3JvbGxTcHknLFxuICAgIHN0cmluZ1RhYiAgICAgICA9ICdUYWInLFxuICAgIHN0cmluZ1Rvb2x0aXAgICA9ICdUb29sdGlwJyxcbiAgXG4gICAgLy8gb3B0aW9ucyBEQVRBIEFQSVxuICAgIGRhdGFiYWNrZHJvcCAgICAgID0gJ2RhdGEtYmFja2Ryb3AnLFxuICAgIGRhdGFLZXlib2FyZCAgICAgID0gJ2RhdGEta2V5Ym9hcmQnLFxuICAgIGRhdGFUYXJnZXQgICAgICAgID0gJ2RhdGEtdGFyZ2V0JyxcbiAgICBkYXRhSW50ZXJ2YWwgICAgICA9ICdkYXRhLWludGVydmFsJyxcbiAgICBkYXRhSGVpZ2h0ICAgICAgICA9ICdkYXRhLWhlaWdodCcsXG4gICAgZGF0YVBhdXNlICAgICAgICAgPSAnZGF0YS1wYXVzZScsXG4gICAgZGF0YVRpdGxlICAgICAgICAgPSAnZGF0YS10aXRsZScsXG4gICAgZGF0YU9yaWdpbmFsVGl0bGUgPSAnZGF0YS1vcmlnaW5hbC10aXRsZScsXG4gICAgZGF0YU9yaWdpbmFsVGV4dCAgPSAnZGF0YS1vcmlnaW5hbC10ZXh0JyxcbiAgICBkYXRhRGlzbWlzc2libGUgICA9ICdkYXRhLWRpc21pc3NpYmxlJyxcbiAgICBkYXRhVHJpZ2dlciAgICAgICA9ICdkYXRhLXRyaWdnZXInLFxuICAgIGRhdGFBbmltYXRpb24gICAgID0gJ2RhdGEtYW5pbWF0aW9uJyxcbiAgICBkYXRhQ29udGFpbmVyICAgICA9ICdkYXRhLWNvbnRhaW5lcicsXG4gICAgZGF0YVBsYWNlbWVudCAgICAgPSAnZGF0YS1wbGFjZW1lbnQnLFxuICAgIGRhdGFEZWxheSAgICAgICAgID0gJ2RhdGEtZGVsYXknLFxuICAgIGRhdGFPZmZzZXRUb3AgICAgID0gJ2RhdGEtb2Zmc2V0LXRvcCcsXG4gICAgZGF0YU9mZnNldEJvdHRvbSAgPSAnZGF0YS1vZmZzZXQtYm90dG9tJyxcbiAgXG4gICAgLy8gb3B0aW9uIGtleXNcbiAgICBiYWNrZHJvcCA9ICdiYWNrZHJvcCcsIGtleWJvYXJkID0gJ2tleWJvYXJkJywgZGVsYXkgPSAnZGVsYXknLFxuICAgIGNvbnRlbnQgPSAnY29udGVudCcsIHRhcmdldCA9ICd0YXJnZXQnLFxuICAgIGludGVydmFsID0gJ2ludGVydmFsJywgcGF1c2UgPSAncGF1c2UnLCBhbmltYXRpb24gPSAnYW5pbWF0aW9uJyxcbiAgICBwbGFjZW1lbnQgPSAncGxhY2VtZW50JywgY29udGFpbmVyID0gJ2NvbnRhaW5lcicsXG4gIFxuICAgIC8vIGJveCBtb2RlbFxuICAgIG9mZnNldFRvcCAgICA9ICdvZmZzZXRUb3AnLCAgICAgIG9mZnNldEJvdHRvbSAgID0gJ29mZnNldEJvdHRvbScsXG4gICAgb2Zmc2V0TGVmdCAgID0gJ29mZnNldExlZnQnLFxuICAgIHNjcm9sbFRvcCAgICA9ICdzY3JvbGxUb3AnLCAgICAgIHNjcm9sbExlZnQgICAgID0gJ3Njcm9sbExlZnQnLFxuICAgIGNsaWVudFdpZHRoICA9ICdjbGllbnRXaWR0aCcsICAgIGNsaWVudEhlaWdodCAgID0gJ2NsaWVudEhlaWdodCcsXG4gICAgb2Zmc2V0V2lkdGggID0gJ29mZnNldFdpZHRoJywgICAgb2Zmc2V0SGVpZ2h0ICAgPSAnb2Zmc2V0SGVpZ2h0JyxcbiAgICBpbm5lcldpZHRoICAgPSAnaW5uZXJXaWR0aCcsICAgICBpbm5lckhlaWdodCAgICA9ICdpbm5lckhlaWdodCcsXG4gICAgc2Nyb2xsSGVpZ2h0ID0gJ3Njcm9sbEhlaWdodCcsICAgaGVpZ2h0ICAgICAgICAgPSAnaGVpZ2h0JyxcbiAgXG4gICAgLy8gYXJpYVxuICAgIGFyaWFFeHBhbmRlZCA9ICdhcmlhLWV4cGFuZGVkJyxcbiAgICBhcmlhSGlkZGVuICAgPSAnYXJpYS1oaWRkZW4nLFxuICBcbiAgICAvLyBldmVudCBuYW1lc1xuICAgIGNsaWNrRXZlbnQgICAgPSAnY2xpY2snLFxuICAgIGhvdmVyRXZlbnQgICAgPSAnaG92ZXInLFxuICAgIGtleWRvd25FdmVudCAgPSAna2V5ZG93bicsXG4gICAga2V5dXBFdmVudCAgICA9ICdrZXl1cCcsIFxuICAgIHJlc2l6ZUV2ZW50ICAgPSAncmVzaXplJyxcbiAgICBzY3JvbGxFdmVudCAgID0gJ3Njcm9sbCcsXG4gICAgLy8gb3JpZ2luYWxFdmVudHNcbiAgICBzaG93RXZlbnQgICAgID0gJ3Nob3cnLFxuICAgIHNob3duRXZlbnQgICAgPSAnc2hvd24nLFxuICAgIGhpZGVFdmVudCAgICAgPSAnaGlkZScsXG4gICAgaGlkZGVuRXZlbnQgICA9ICdoaWRkZW4nLFxuICAgIGNsb3NlRXZlbnQgICAgPSAnY2xvc2UnLFxuICAgIGNsb3NlZEV2ZW50ICAgPSAnY2xvc2VkJyxcbiAgICBzbGlkRXZlbnQgICAgID0gJ3NsaWQnLFxuICAgIHNsaWRlRXZlbnQgICAgPSAnc2xpZGUnLFxuICAgIGNoYW5nZUV2ZW50ICAgPSAnY2hhbmdlJyxcbiAgXG4gICAgLy8gb3RoZXJcbiAgICBnZXRBdHRyaWJ1dGUgICAgICAgICAgID0gJ2dldEF0dHJpYnV0ZScsXG4gICAgc2V0QXR0cmlidXRlICAgICAgICAgICA9ICdzZXRBdHRyaWJ1dGUnLFxuICAgIGhhc0F0dHJpYnV0ZSAgICAgICAgICAgPSAnaGFzQXR0cmlidXRlJyxcbiAgICBjcmVhdGVFbGVtZW50ICAgICAgICAgID0gJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIGFwcGVuZENoaWxkICAgICAgICAgICAgPSAnYXBwZW5kQ2hpbGQnLFxuICAgIGlubmVySFRNTCAgICAgICAgICAgICAgPSAnaW5uZXJIVE1MJywgIFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lICAgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnLFxuICAgIHByZXZlbnREZWZhdWx0ICAgICAgICAgPSAncHJldmVudERlZmF1bHQnLFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdCAgPSAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JyxcbiAgICBxdWVyeVNlbGVjdG9yQWxsICAgICAgID0gJ3F1ZXJ5U2VsZWN0b3JBbGwnLFxuICAgIGdldEVsZW1lbnRzQnlDTEFTU05BTUUgPSAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZScsXG4gIFxuICAgIGluZGV4T2YgICAgICA9ICdpbmRleE9mJyxcbiAgICBwYXJlbnROb2RlICAgPSAncGFyZW50Tm9kZScsXG4gICAgbGVuZ3RoICAgICAgID0gJ2xlbmd0aCcsXG4gICAgdG9Mb3dlckNhc2UgID0gJ3RvTG93ZXJDYXNlJyxcbiAgICBUcmFuc2l0aW9uICAgPSAnVHJhbnNpdGlvbicsXG4gICAgV2Via2l0ICAgICAgID0gJ1dlYmtpdCcsXG4gICAgc3R5bGUgICAgICAgID0gJ3N0eWxlJyxcbiAgICBwdXNoICAgICAgICAgPSAncHVzaCcsXG4gICAgdGFiaW5kZXggICAgID0gJ3RhYmluZGV4JyxcbiAgICBjb250YWlucyAgICAgPSAnY29udGFpbnMnLFxuICBcbiAgICBhY3RpdmUgICAgID0gJ2FjdGl2ZScsXG4gICAgc2hvd0NsYXNzICA9ICdzaG93JyxcbiAgICBjb2xsYXBzaW5nID0gJ2NvbGxhcHNpbmcnLFxuICAgIGRpc2FibGVkICAgPSAnZGlzYWJsZWQnLFxuICAgIGxvYWRpbmcgICAgPSAnbG9hZGluZycsXG4gICAgbGVmdCAgICAgICA9ICdsZWZ0JyxcbiAgICByaWdodCAgICAgID0gJ3JpZ2h0JyxcbiAgICB0b3AgICAgICAgID0gJ3RvcCcsXG4gICAgYm90dG9tICAgICA9ICdib3R0b20nLFxuICBcbiAgICAvLyB0b29sdGlwIC8gcG9wb3ZlclxuICAgIG1vdXNlSG92ZXIgPSAoJ29ubW91c2VsZWF2ZScgaW4gRE9DKSA/IFsgJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddIDogWyAnbW91c2VvdmVyJywgJ21vdXNlb3V0JyBdLFxuICAgIHRpcFBvc2l0aW9ucyA9IC9cXGIodG9wfGJvdHRvbXxsZWZ0fHJpZ2h0KSsvLFxuICAgIFxuICAgIC8vIG1vZGFsXG4gICAgbW9kYWxPdmVybGF5ID0gMCxcbiAgICBmaXhlZFRvcCA9ICdmaXhlZC10b3AnLFxuICAgIGZpeGVkQm90dG9tID0gJ2ZpeGVkLWJvdHRvbScsXG4gICAgXG4gICAgLy8gdHJhbnNpdGlvbkVuZCBzaW5jZSAyLjAuNFxuICAgIHN1cHBvcnRUcmFuc2l0aW9ucyA9IFdlYmtpdCtUcmFuc2l0aW9uIGluIEhUTUxbc3R5bGVdIHx8IFRyYW5zaXRpb25bdG9Mb3dlckNhc2VdKCkgaW4gSFRNTFtzdHlsZV0sXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gV2Via2l0K1RyYW5zaXRpb24gaW4gSFRNTFtzdHlsZV0gPyBXZWJraXRbdG9Mb3dlckNhc2VdKCkrVHJhbnNpdGlvbisnRW5kJyA6IFRyYW5zaXRpb25bdG9Mb3dlckNhc2VdKCkrJ2VuZCcsXG4gIFxuICAgIC8vIHNldCBuZXcgZm9jdXMgZWxlbWVudCBzaW5jZSAyLjAuM1xuICAgIHNldEZvY3VzID0gZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgICBlbGVtZW50LmZvY3VzID8gZWxlbWVudC5mb2N1cygpIDogZWxlbWVudC5zZXRBY3RpdmUoKTtcbiAgICB9LFxuICBcbiAgICAvLyBjbGFzcyBtYW5pcHVsYXRpb24sIHNpbmNlIDIuMC4wIHJlcXVpcmVzIHBvbHlmaWxsLmpzXG4gICAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LGNsYXNzTkFNRSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTkFNRSk7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsY2xhc3NOQU1FKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOQU1FKTtcbiAgICB9LFxuICAgIGhhc0NsYXNzID0gZnVuY3Rpb24oZWxlbWVudCxjbGFzc05BTUUpeyAvLyBzaW5jZSAyLjAuMFxuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0W2NvbnRhaW5zXShjbGFzc05BTUUpO1xuICAgIH0sXG4gIFxuICAgIC8vIHNlbGVjdGlvbiBtZXRob2RzXG4gICAgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQsY2xhc3NOQU1FKSB7IC8vIHJldHVybnMgQXJyYXlcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnRbZ2V0RWxlbWVudHNCeUNMQVNTTkFNRV0oIGNsYXNzTkFNRSApKTtcbiAgICB9LFxuICAgIHF1ZXJ5RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFyZW50KSB7XG4gICAgICB2YXIgbG9va1VwID0gcGFyZW50ID8gcGFyZW50IDogRE9DO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcgPyBzZWxlY3RvciA6IGxvb2tVcC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIGdldENsb3Nlc3QgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHsgLy9lbGVtZW50IGlzIHRoZSBlbGVtZW50IGFuZCBzZWxlY3RvciBpcyBmb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnQgdG8gZmluZFxuICAgICAgLy8gc291cmNlIGh0dHA6Ly9nb21ha2V0aGluZ3MuY29tL2NsaW1iaW5nLXVwLWFuZC1kb3duLXRoZS1kb20tdHJlZS13aXRoLXZhbmlsbGEtamF2YXNjcmlwdC9cbiAgICAgIHZhciBmaXJzdENoYXIgPSBzZWxlY3Rvci5jaGFyQXQoMCksIHNlbGVjdG9yU3Vic3RyaW5nID0gc2VsZWN0b3Iuc3Vic3RyKDEpO1xuICAgICAgaWYgKCBmaXJzdENoYXIgPT09ICcuJyApIHsvLyBJZiBzZWxlY3RvciBpcyBhIGNsYXNzXG4gICAgICAgIGZvciAoIDsgZWxlbWVudCAmJiBlbGVtZW50ICE9PSBET0M7IGVsZW1lbnQgPSBlbGVtZW50W3BhcmVudE5vZGVdICkgeyAvLyBHZXQgY2xvc2VzdCBtYXRjaFxuICAgICAgICAgIGlmICggcXVlcnlFbGVtZW50KHNlbGVjdG9yLGVsZW1lbnRbcGFyZW50Tm9kZV0pICE9PSBudWxsICYmIGhhc0NsYXNzKGVsZW1lbnQsc2VsZWN0b3JTdWJzdHJpbmcpICkgeyByZXR1cm4gZWxlbWVudDsgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCBmaXJzdENoYXIgPT09ICcjJyApIHsgLy8gSWYgc2VsZWN0b3IgaXMgYW4gSURcbiAgICAgICAgZm9yICggOyBlbGVtZW50ICYmIGVsZW1lbnQgIT09IERPQzsgZWxlbWVudCA9IGVsZW1lbnRbcGFyZW50Tm9kZV0gKSB7IC8vIEdldCBjbG9zZXN0IG1hdGNoXG4gICAgICAgICAgaWYgKCBlbGVtZW50LmlkID09PSBzZWxlY3RvclN1YnN0cmluZyApIHsgcmV0dXJuIGVsZW1lbnQ7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIFxuICAgIC8vIGV2ZW50IGF0dGFjaCBqUXVlcnkgc3R5bGUgLyB0cmlnZ2VyICBzaW5jZSAxLjIuMFxuICAgIG9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9mZiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikgeyAvLyBvbmUgc2luY2UgMi4wLjRcbiAgICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcihlKXtcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgICAgb2ZmKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyV3JhcHBlcik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCxoYW5kbGVyKXsgLy8gZW11bGF0ZVRyYW5zaXRpb25FbmQgc2luY2UgMi4wLjRcbiAgICAgIGlmIChzdXBwb3J0VHJhbnNpdGlvbnMpIHsgb25lKGVsZW1lbnQsIHRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24oZSl7IGhhbmRsZXIoZSk7IH0pOyB9XG4gICAgICBlbHNlIHsgaGFuZGxlcigpOyB9XG4gICAgfSxcbiAgICBib290c3RyYXBDdXN0b21FdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNvbXBvbmVudE5hbWUsIHJlbGF0ZWQpIHtcbiAgICAgIHZhciBPcmlnaW5hbEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCBldmVudE5hbWUgKyAnLmJzLicgKyBjb21wb25lbnROYW1lKTtcbiAgICAgIE9yaWdpbmFsQ3VzdG9tRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWQ7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoT3JpZ2luYWxDdXN0b21FdmVudCk7XG4gICAgfSxcbiAgXG4gICAgLy8gdG9vbHRpcCAvIHBvcG92ZXIgc3R1ZmZcbiAgICBnZXRTY3JvbGwgPSBmdW5jdGlvbigpIHsgLy8gYWxzbyBBZmZpeCBhbmQgU2Nyb2xsU3B5IHVzZXMgaXRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHkgOiBnbG9iYWxPYmplY3QucGFnZVlPZmZzZXQgfHwgSFRNTFtzY3JvbGxUb3BdLFxuICAgICAgICB4IDogZ2xvYmFsT2JqZWN0LnBhZ2VYT2Zmc2V0IHx8IEhUTUxbc2Nyb2xsTGVmdF1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0eWxlVGlwID0gZnVuY3Rpb24obGluayxlbGVtZW50LHBvc2l0aW9uLHBhcmVudCkgeyAvLyBib3RoIHBvcG92ZXJzIGFuZCB0b29sdGlwcyAodGFyZ2V0LHRvb2x0aXAscGxhY2VtZW50LGVsZW1lbnRUb0FwcGVuZFRvKVxuICAgICAgdmFyIGVsZW1lbnREaW1lbnNpb25zID0geyB3IDogZWxlbWVudFtvZmZzZXRXaWR0aF0sIGg6IGVsZW1lbnRbb2Zmc2V0SGVpZ2h0XSB9LFxuICAgICAgICAgIHdpbmRvd1dpZHRoID0gKEhUTUxbY2xpZW50V2lkdGhdIHx8IERPQ1tib2R5XVtjbGllbnRXaWR0aF0pLFxuICAgICAgICAgIHdpbmRvd0hlaWdodCA9IChIVE1MW2NsaWVudEhlaWdodF0gfHwgRE9DW2JvZHldW2NsaWVudEhlaWdodF0pLFxuICAgICAgICAgIHJlY3QgPSBsaW5rW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKSxcbiAgICAgICAgICBzY3JvbGwgPSBwYXJlbnQgPT09IERPQ1tib2R5XSA/IGdldFNjcm9sbCgpIDogeyB4OiBwYXJlbnRbb2Zmc2V0TGVmdF0gKyBwYXJlbnRbc2Nyb2xsTGVmdF0sIHk6IHBhcmVudFtvZmZzZXRUb3BdICsgcGFyZW50W3Njcm9sbFRvcF0gfSxcbiAgICAgICAgICBsaW5rRGltZW5zaW9ucyA9IHsgdzogcmVjdFtyaWdodF0gLSByZWN0W2xlZnRdLCBoOiByZWN0W2JvdHRvbV0gLSByZWN0W3RvcF0gfSxcbiAgICAgICAgICBpc1BvcG92ZXIgPSBoYXNDbGFzcyhlbGVtZW50LCdwb3BvdmVyJyksXG4gICAgICAgICAgdG9wUG9zaXRpb24sIGxlZnRQb3NpdGlvbiwgXG4gICAgICAgICAgXG4gICAgICAgICAgYXJyb3cgPSBxdWVyeUVsZW1lbnQoJy5hcnJvdycsZWxlbWVudCksXG4gICAgICAgICAgYXJyb3dUb3AsIGFycm93TGVmdCwgYXJyb3dXaWR0aCwgYXJyb3dIZWlnaHQsXG4gIFxuICAgICAgICAgIGhhbGZUb3BFeGNlZWQgPSByZWN0W3RvcF0gKyBsaW5rRGltZW5zaW9ucy5oLzIgLSBlbGVtZW50RGltZW5zaW9ucy5oLzIgPCAwLFxuICAgICAgICAgIGhhbGZMZWZ0RXhjZWVkID0gcmVjdFtsZWZ0XSArIGxpbmtEaW1lbnNpb25zLncvMiAtIGVsZW1lbnREaW1lbnNpb25zLncvMiA8IDAsXG4gICAgICAgICAgaGFsZlJpZ2h0RXhjZWVkID0gcmVjdFtsZWZ0XSArIGVsZW1lbnREaW1lbnNpb25zLncvMiArIGxpbmtEaW1lbnNpb25zLncvMiA+PSB3aW5kb3dXaWR0aCxcbiAgICAgICAgICBoYWxmQm90dG9tRXhjZWVkID0gcmVjdFt0b3BdICsgZWxlbWVudERpbWVuc2lvbnMuaC8yICsgbGlua0RpbWVuc2lvbnMuaC8yID49IHdpbmRvd0hlaWdodCxcbiAgICAgICAgICB0b3BFeGNlZWQgPSByZWN0W3RvcF0gLSBlbGVtZW50RGltZW5zaW9ucy5oIDwgMCxcbiAgICAgICAgICBsZWZ0RXhjZWVkID0gcmVjdFtsZWZ0XSAtIGVsZW1lbnREaW1lbnNpb25zLncgPCAwLFxuICAgICAgICAgIGJvdHRvbUV4Y2VlZCA9IHJlY3RbdG9wXSArIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oID49IHdpbmRvd0hlaWdodCxcbiAgICAgICAgICByaWdodEV4Y2VlZCA9IHJlY3RbbGVmdF0gKyBlbGVtZW50RGltZW5zaW9ucy53ICsgbGlua0RpbWVuc2lvbnMudyA+PSB3aW5kb3dXaWR0aDtcbiAgXG4gICAgICAvLyByZWNvbXB1dGUgcG9zaXRpb25cbiAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uID09PSBsZWZ0IHx8IHBvc2l0aW9uID09PSByaWdodCkgJiYgbGVmdEV4Y2VlZCAmJiByaWdodEV4Y2VlZCA/IHRvcCA6IHBvc2l0aW9uOyAvLyBmaXJzdCwgd2hlbiBib3RoIGxlZnQgYW5kIHJpZ2h0IGxpbWl0cyBhcmUgZXhjZWVkZWQsIHdlIGZhbGwgYmFjayB0byB0b3B8Ym90dG9tXG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB0b3AgJiYgdG9wRXhjZWVkID8gYm90dG9tIDogcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSBib3R0b20gJiYgYm90dG9tRXhjZWVkID8gdG9wIDogcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSBsZWZ0ICYmIGxlZnRFeGNlZWQgPyByaWdodCA6IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gcmlnaHQgJiYgcmlnaHRFeGNlZWQgPyBsZWZ0IDogcG9zaXRpb247XG4gICAgICBcbiAgICAgIC8vIHVwZGF0ZSB0b29sdGlwL3BvcG92ZXIgY2xhc3NcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lW2luZGV4T2ZdKHBvc2l0aW9uKSA9PT0gLTEgJiYgKGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh0aXBQb3NpdGlvbnMscG9zaXRpb24pKTtcbiAgXG4gICAgICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gICAgICBhcnJvd1dpZHRoID0gYXJyb3dbb2Zmc2V0V2lkdGhdOyBhcnJvd0hlaWdodCA9IGFycm93W29mZnNldEhlaWdodF07XG4gIFxuICAgICAgLy8gYXBwbHkgc3R5bGluZyB0byB0b29sdGlwIG9yIHBvcG92ZXJcbiAgICAgIGlmICggcG9zaXRpb24gPT09IGxlZnQgfHwgcG9zaXRpb24gPT09IHJpZ2h0ICkgeyAvLyBzZWNvbmRhcnl8c2lkZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gbGVmdCApIHsgLy8gTEVGVFxuICAgICAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3RbbGVmdF0gKyBzY3JvbGwueCAtIGVsZW1lbnREaW1lbnNpb25zLncgLSAoIGlzUG9wb3ZlciA/IGFycm93V2lkdGggOiAwICk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFJJR0hUXG4gICAgICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdFtsZWZ0XSArIHNjcm9sbC54ICsgbGlua0RpbWVuc2lvbnMudztcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gYWRqdXN0IHRvcCBhbmQgYXJyb3dcbiAgICAgICAgaWYgKGhhbGZUb3BFeGNlZWQpIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55O1xuICAgICAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaC8yIC0gYXJyb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoYWxmQm90dG9tRXhjZWVkKSB7XG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgICAgICAgIGFycm93VG9wID0gZWxlbWVudERpbWVuc2lvbnMuaCAtIGxpbmtEaW1lbnNpb25zLmgvMiAtIGFycm93V2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmgvMiArIGxpbmtEaW1lbnNpb25zLmgvMjtcbiAgICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmgvMiAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCowLjkgOiBhcnJvd0hlaWdodC8yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICggcG9zaXRpb24gPT09IHRvcCB8fCBwb3NpdGlvbiA9PT0gYm90dG9tICkgeyAvLyBwcmltYXJ5fHZlcnRpY2FsIHBvc2l0aW9uc1xuICAgICAgICBpZiAoIHBvc2l0aW9uID09PSB0b3ApIHsgLy8gVE9QXG4gICAgICAgICAgdG9wUG9zaXRpb24gPSAgcmVjdFt0b3BdICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC0gKCBpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDAgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gQk9UVE9NXG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRqdXN0IGxlZnQgfCByaWdodCBhbmQgYWxzbyB0aGUgYXJyb3dcbiAgICAgICAgaWYgKGhhbGZMZWZ0RXhjZWVkKSB7XG4gICAgICAgICAgbGVmdFBvc2l0aW9uID0gMDtcbiAgICAgICAgICBhcnJvd0xlZnQgPSByZWN0W2xlZnRdICsgbGlua0RpbWVuc2lvbnMudy8yIC0gYXJyb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoYWxmUmlnaHRFeGNlZWQpIHtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSB3aW5kb3dXaWR0aCAtIGVsZW1lbnREaW1lbnNpb25zLncqMS4wMTtcbiAgICAgICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC0gKCB3aW5kb3dXaWR0aCAtIHJlY3RbbGVmdF0gKSArIGxpbmtEaW1lbnNpb25zLncvMiAtIGFycm93V2lkdGgvMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0W2xlZnRdICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53LzIgKyBsaW5rRGltZW5zaW9ucy53LzI7XG4gICAgICAgICAgYXJyb3dMZWZ0ID0gZWxlbWVudERpbWVuc2lvbnMudy8yIC0gYXJyb3dXaWR0aC8yO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgLy8gYXBwbHkgc3R5bGUgdG8gdG9vbHRpcC9wb3BvdmVyIGFuZCBpdHMgYXJyb3dcbiAgICAgIGVsZW1lbnRbc3R5bGVdW3RvcF0gPSB0b3BQb3NpdGlvbiArICdweCc7XG4gICAgICBlbGVtZW50W3N0eWxlXVtsZWZ0XSA9IGxlZnRQb3NpdGlvbiArICdweCc7XG4gIFxuICAgICAgYXJyb3dUb3AgJiYgKGFycm93W3N0eWxlXVt0b3BdID0gYXJyb3dUb3AgKyAncHgnKTtcbiAgICAgIGFycm93TGVmdCAmJiAoYXJyb3dbc3R5bGVdW2xlZnRdID0gYXJyb3dMZWZ0ICsgJ3B4Jyk7XG4gICAgfTtcbiAgXG4gIEJTTi52ZXJzaW9uID0gJzIuMC4yMic7XG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBBbGVydFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIEFMRVJUIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PVxuICB2YXIgQWxlcnQgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgXG4gICAgLy8gYmluZCwgdGFyZ2V0IGFsZXJ0LCBkdXJhdGlvbiBhbmQgc3R1ZmZcbiAgICB2YXIgc2VsZiA9IHRoaXMsIGNvbXBvbmVudCA9ICdhbGVydCcsXG4gICAgICBhbGVydCA9IGdldENsb3Nlc3QoZWxlbWVudCwnLicrY29tcG9uZW50KSxcbiAgICAgIHRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24oKXsgaGFzQ2xhc3MoYWxlcnQsJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFsZXJ0LHRyYW5zaXRpb25FbmRIYW5kbGVyKSA6IHRyYW5zaXRpb25FbmRIYW5kbGVyKCk7IH0sXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIGFsZXJ0ID0gZ2V0Q2xvc2VzdChlW3RhcmdldF0sJy4nK2NvbXBvbmVudCk7XG4gICAgICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoJ1snK2RhdGFEaXNtaXNzKyc9XCInK2NvbXBvbmVudCsnXCJdJyxhbGVydCk7XG4gICAgICAgIGVsZW1lbnQgJiYgYWxlcnQgJiYgKGVsZW1lbnQgPT09IGVbdGFyZ2V0XSB8fCBlbGVtZW50W2NvbnRhaW5zXShlW3RhcmdldF0pKSAmJiBzZWxmLmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGFsZXJ0LCBjbG9zZWRFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgb2ZmKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7IC8vIGRldGFjaCBpdCdzIGxpc3RlbmVyXG4gICAgICAgIGFsZXJ0W3BhcmVudE5vZGVdLnJlbW92ZUNoaWxkKGFsZXJ0KTtcbiAgICAgIH07XG4gICAgXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggYWxlcnQgJiYgZWxlbWVudCAmJiBoYXNDbGFzcyhhbGVydCxzaG93Q2xhc3MpICkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGFsZXJ0LCBjbG9zZUV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICByZW1vdmVDbGFzcyhhbGVydCxzaG93Q2xhc3MpO1xuICAgICAgICBhbGVydCAmJiB0cmlnZ2VySGFuZGxlcigpO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICBpZiAoICEoc3RyaW5nQWxlcnQgaW4gZWxlbWVudCApICkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxlbWVudFtzdHJpbmdBbGVydF0gPSBzZWxmO1xuICB9O1xuICBcbiAgLy8gQUxFUlQgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT1cbiAgc3VwcG9ydHNbcHVzaF0oW3N0cmluZ0FsZXJ0LCBBbGVydCwgJ1snK2RhdGFEaXNtaXNzKyc9XCJhbGVydFwiXSddKTtcbiAgXG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBCdXR0b25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIEJVVFRPTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cbiAgdmFyIEJ1dHRvbiA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgXG4gICAgLy8gY29uc3RhbnRcbiAgICB2YXIgdG9nZ2xlZCA9IGZhbHNlLCAvLyB0b2dnbGVkIG1ha2VzIHN1cmUgdG8gcHJldmVudCB0cmlnZ2VyaW5nIHR3aWNlIHRoZSBjaGFuZ2UuYnMuYnV0dG9uIGV2ZW50c1xuICBcbiAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICBjb21wb25lbnQgPSAnYnV0dG9uJyxcbiAgICAgICAgY2hlY2tlZCA9ICdjaGVja2VkJyxcbiAgICAgICAgcmVzZXQgPSAncmVzZXQnLFxuICAgICAgICBMQUJFTCA9ICdMQUJFTCcsXG4gICAgICAgIElOUFVUID0gJ0lOUFVUJyxcbiAgXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbihlKXsgXG4gICAgICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICAgICAga2V5ID09PSAzMiAmJiBlW3RhcmdldF0gPT09IERPQy5hY3RpdmVFbGVtZW50ICYmIHRvZ2dsZShlKTtcbiAgICAgIH0sXG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZnVuY3Rpb24oZSl7IFxuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICAgIGtleSA9PT0gMzIgJiYgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGVbdGFyZ2V0XS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XSA6IGVbdGFyZ2V0XVtwYXJlbnROb2RlXS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XVtwYXJlbnROb2RlXSA6IG51bGw7IC8vIHRoZSAuYnRuIGxhYmVsXG4gICAgICAgIFxuICAgICAgICBpZiAoICFsYWJlbCApIHJldHVybjsgLy9yZWFjdCBpZiBhIGxhYmVsIG9yIGl0cyBpbW1lZGlhdGUgY2hpbGQgaXMgY2xpY2tlZFxuICBcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZVt0YXJnZXRdLCAvLyB0aGUgYnV0dG9uIGl0c2VsZiwgdGhlIHRhcmdldCBvZiB0aGUgaGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgIGxhYmVscyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZXZlbnRUYXJnZXRbcGFyZW50Tm9kZV0sJ2J0bicpLCAvLyBhbGwgdGhlIGJ1dHRvbiBncm91cCBidXR0b25zXG4gICAgICAgICAgaW5wdXQgPSBsYWJlbFtnZXRFbGVtZW50c0J5VGFnTmFtZV0oSU5QVVQpWzBdO1xuICBcbiAgICAgICAgaWYgKCAhaW5wdXQgKSByZXR1cm47IC8vcmV0dXJuIGlmIG5vIGlucHV0IGZvdW5kXG4gIFxuICAgICAgICAvLyBtYW5hZ2UgdGhlIGRvbSBtYW5pcHVsYXRpb25cbiAgICAgICAgaWYgKCBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnICkgeyAvL2NoZWNrYm94ZXNcbiAgICAgICAgICBpZiAoICFpbnB1dFtjaGVja2VkXSApIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGxhYmVsLGFjdGl2ZSk7XG4gICAgICAgICAgICBpbnB1dFtnZXRBdHRyaWJ1dGVdKGNoZWNrZWQpO1xuICAgICAgICAgICAgaW5wdXRbc2V0QXR0cmlidXRlXShjaGVja2VkLGNoZWNrZWQpO1xuICAgICAgICAgICAgaW5wdXRbY2hlY2tlZF0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhsYWJlbCxhY3RpdmUpO1xuICAgICAgICAgICAgaW5wdXRbZ2V0QXR0cmlidXRlXShjaGVja2VkKTtcbiAgICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZShjaGVja2VkKTtcbiAgICAgICAgICAgIGlucHV0W2NoZWNrZWRdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBpZiAoIXRvZ2dsZWQpIHsgLy8gcHJldmVudCB0cmlnZ2VyaW5nIHRoZSBldmVudCB0d2ljZVxuICAgICAgICAgICAgdG9nZ2xlZCA9IHRydWU7XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGlucHV0LCBjaGFuZ2VFdmVudCwgY29tcG9uZW50KTsgLy90cmlnZ2VyIHRoZSBjaGFuZ2UgZm9yIHRoZSBpbnB1dFxuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBjaGFuZ2VFdmVudCwgY29tcG9uZW50KTsgLy90cmlnZ2VyIHRoZSBjaGFuZ2UgZm9yIHRoZSBidG4tZ3JvdXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICggaW5wdXQudHlwZSA9PT0gJ3JhZGlvJyAmJiAhdG9nZ2xlZCApIHsgLy8gcmFkaW8gYnV0dG9uc1xuICAgICAgICAgIGlmICggIWlucHV0W2NoZWNrZWRdICkgeyAvLyBkb24ndCB0cmlnZ2VyIGlmIGFscmVhZHkgYWN0aXZlXG4gICAgICAgICAgICBhZGRDbGFzcyhsYWJlbCxhY3RpdmUpO1xuICAgICAgICAgICAgaW5wdXRbc2V0QXR0cmlidXRlXShjaGVja2VkLGNoZWNrZWQpO1xuICAgICAgICAgICAgaW5wdXRbY2hlY2tlZF0gPSB0cnVlO1xuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChpbnB1dCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgaW5wdXRcbiAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgYnRuLWdyb3VwXG4gIFxuICAgICAgICAgICAgdG9nZ2xlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGwgPSBsYWJlbHNbbGVuZ3RoXTsgaTxsbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlckxhYmVsID0gbGFiZWxzW2ldLCBvdGhlcklucHV0ID0gb3RoZXJMYWJlbFtnZXRFbGVtZW50c0J5VGFnTmFtZV0oSU5QVVQpWzBdO1xuICAgICAgICAgICAgICBpZiAoIG90aGVyTGFiZWwgIT09IGxhYmVsICYmIGhhc0NsYXNzKG90aGVyTGFiZWwsYWN0aXZlKSApICB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mob3RoZXJMYWJlbCxhY3RpdmUpO1xuICAgICAgICAgICAgICAgIG90aGVySW5wdXQucmVtb3ZlQXR0cmlidXRlKGNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIG90aGVySW5wdXRbY2hlY2tlZF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKG90aGVySW5wdXQsIGNoYW5nZUV2ZW50LCBjb21wb25lbnQpOyAvLyB0cmlnZ2VyIHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgdG9nZ2xlZCA9IGZhbHNlOyB9LCA1MCApO1xuICAgICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggISggc3RyaW5nQnV0dG9uIGluIGVsZW1lbnQgKSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKCBlbGVtZW50LCBjbGlja0V2ZW50LCB0b2dnbGUgKTtcbiAgICAgIHF1ZXJ5RWxlbWVudCgnWycrdGFiaW5kZXgrJ10nLGVsZW1lbnQpICYmIG9uKCBlbGVtZW50LCBrZXl1cEV2ZW50LCBrZXlIYW5kbGVyICksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24oIGVsZW1lbnQsIGtleWRvd25FdmVudCwgcHJldmVudFNjcm9sbCApOyAgICBcbiAgICB9XG4gIFxuICAgIC8vIGFjdGl2YXRlIGl0ZW1zIG9uIGxvYWRcbiAgICB2YXIgbGFiZWxzVG9BQ3RpdmF0ZSA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCwgJ2J0bicpLCBsYmxsID0gbGFiZWxzVG9BQ3RpdmF0ZVtsZW5ndGhdO1xuICAgIGZvciAodmFyIGk9MDsgaTxsYmxsOyBpKyspIHtcbiAgICAgICFoYXNDbGFzcyhsYWJlbHNUb0FDdGl2YXRlW2ldLGFjdGl2ZSkgJiYgcXVlcnlFbGVtZW50KCdpbnB1dDpjaGVja2VkJyxsYWJlbHNUb0FDdGl2YXRlW2ldKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYWRkQ2xhc3MobGFiZWxzVG9BQ3RpdmF0ZVtpXSxhY3RpdmUpO1xuICAgIH1cbiAgICBlbGVtZW50W3N0cmluZ0J1dHRvbl0gPSB0aGlzO1xuICB9O1xuICBcbiAgLy8gQlVUVE9OIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ0J1dHRvbiwgQnV0dG9uLCAnWycrZGF0YVRvZ2dsZSsnPVwiYnV0dG9uc1wiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IENhcm91c2VsXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gQ0FST1VTRUwgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09XG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zICkge1xuICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBpbnRlcnZhbEF0dHJpYnV0ZSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhSW50ZXJ2YWwpLFxuICAgICAgICBpbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnNbaW50ZXJ2YWxdLFxuICAgICAgICBpbnRlcnZhbERhdGEgPSBpbnRlcnZhbEF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJyA/IDAgOiBwYXJzZUludChpbnRlcnZhbEF0dHJpYnV0ZSkgfHwgNTAwMCwgIC8vIGJvb3RzdHJhcCBjYXJvdXNlbCBkZWZhdWx0IGludGVydmFsXG4gICAgICAgIHBhdXNlRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhUGF1c2UpID09PSBob3ZlckV2ZW50IHx8IGZhbHNlLFxuICAgICAgICBrZXlib2FyZERhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUtleWJvYXJkKSA9PT0gJ3RydWUnIHx8IGZhbHNlLFxuICAgICAgXG4gICAgICAgIC8vIHN0cmluZ3NcbiAgICAgICAgY29tcG9uZW50ID0gJ2Nhcm91c2VsJyxcbiAgICAgICAgcGF1c2VkID0gJ3BhdXNlZCcsXG4gICAgICAgIGRpcmVjdGlvbiA9ICdkaXJlY3Rpb24nLFxuICAgICAgICBjYXJvdXNlbEl0ZW0gPSAnY2Fyb3VzZWwtaXRlbScsXG4gICAgICAgIGRhdGFTbGlkZVRvID0gJ2RhdGEtc2xpZGUtdG8nOyBcbiAgXG4gICAgdGhpc1trZXlib2FyZF0gPSBvcHRpb25zW2tleWJvYXJkXSA9PT0gdHJ1ZSB8fCBrZXlib2FyZERhdGE7XG4gICAgdGhpc1twYXVzZV0gPSAob3B0aW9uc1twYXVzZV0gPT09IGhvdmVyRXZlbnQgfHwgcGF1c2VEYXRhKSA/IGhvdmVyRXZlbnQgOiBmYWxzZTsgLy8gZmFsc2UgLyBob3ZlclxuICBcbiAgICB0aGlzW2ludGVydmFsXSA9IHR5cGVvZiBpbnRlcnZhbE9wdGlvbiA9PT0gJ251bWJlcicgPyBpbnRlcnZhbE9wdGlvblxuICAgICAgICAgICAgICAgICAgIDogaW50ZXJ2YWxEYXRhID09PSAwID8gMFxuICAgICAgICAgICAgICAgICAgIDogaW50ZXJ2YWxEYXRhO1xuICBcbiAgICAvLyBiaW5kLCBldmVudCB0YXJnZXRzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBpbmRleCA9IGVsZW1lbnQuaW5kZXggPSAwLCB0aW1lciA9IGVsZW1lbnQudGltZXIgPSAwLCBcbiAgICAgIGlzU2xpZGluZyA9IGZhbHNlLCAvLyBpc1NsaWRpbmcgcHJldmVudHMgY2xpY2sgZXZlbnQgaGFuZGxlcnMgd2hlbiBhbmltYXRpb24gaXMgcnVubmluZ1xuICAgICAgc2xpZGVzID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlbGVtZW50LGNhcm91c2VsSXRlbSksIHRvdGFsID0gc2xpZGVzW2xlbmd0aF0sXG4gICAgICBzbGlkZURpcmVjdGlvbiA9IHRoaXNbZGlyZWN0aW9uXSA9IGxlZnQsXG4gICAgICBsZWZ0QXJyb3cgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsY29tcG9uZW50KyctY29udHJvbC1wcmV2JylbMF0sIFxuICAgICAgcmlnaHRBcnJvdyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCxjb21wb25lbnQrJy1jb250cm9sLW5leHQnKVswXSxcbiAgICAgIGluZGljYXRvciA9IHF1ZXJ5RWxlbWVudCggJy4nK2NvbXBvbmVudCsnLWluZGljYXRvcnMnLCBlbGVtZW50ICksXG4gICAgICBpbmRpY2F0b3JzID0gaW5kaWNhdG9yICYmIGluZGljYXRvcltnZXRFbGVtZW50c0J5VGFnTmFtZV0oIFwiTElcIiApIHx8IFtdO1xuICBcbiAgICAvLyBoYW5kbGVyc1xuICAgIHZhciBwYXVzZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICggc2VsZltpbnRlcnZhbF0gIT09ZmFsc2UgJiYgIWhhc0NsYXNzKGVsZW1lbnQscGF1c2VkKSApIHtcbiAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LHBhdXNlZCk7XG4gICAgICAgICAgIWlzU2xpZGluZyAmJiBjbGVhckludGVydmFsKCB0aW1lciApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzdW1lSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHNlbGZbaW50ZXJ2YWxdICE9PSBmYWxzZSAmJiBoYXNDbGFzcyhlbGVtZW50LHBhdXNlZCkgKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCxwYXVzZWQpO1xuICAgICAgICAgICFpc1NsaWRpbmcgJiYgY2xlYXJJbnRlcnZhbCggdGltZXIgKTtcbiAgICAgICAgICAhaXNTbGlkaW5nICYmIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGljYXRvckhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGVbcHJldmVudERlZmF1bHRdKCk7XG4gICAgICAgIGlmIChpc1NsaWRpbmcpIHJldHVybjtcbiAgXG4gICAgICAgIHZhciBldmVudFRhcmdldCA9IGVbdGFyZ2V0XTsgLy8gZXZlbnQgdGFyZ2V0IHwgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW1cbiAgXG4gICAgICAgIGlmICggZXZlbnRUYXJnZXQgJiYgIWhhc0NsYXNzKGV2ZW50VGFyZ2V0LGFjdGl2ZSkgJiYgZXZlbnRUYXJnZXRbZ2V0QXR0cmlidXRlXShkYXRhU2xpZGVUbykgKSB7XG4gICAgICAgICAgaW5kZXggPSBwYXJzZUludCggZXZlbnRUYXJnZXRbZ2V0QXR0cmlidXRlXShkYXRhU2xpZGVUbyksIDEwICk7XG4gICAgICAgIH0gZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuICBcbiAgICAgICAgc2VsZi5zbGlkZVRvKCBpbmRleCApOyAvL0RvIHRoZSBzbGlkZVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2xzSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGVbcHJldmVudERlZmF1bHRdKCk7XG4gICAgICAgIGlmIChpc1NsaWRpbmcpIHJldHVybjtcbiAgXG4gICAgICAgIHZhciBldmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gIFxuICAgICAgICBpZiAoIGV2ZW50VGFyZ2V0ID09PSByaWdodEFycm93ICkge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50VGFyZ2V0ID09PSBsZWZ0QXJyb3cgKSB7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgc2VsZi5zbGlkZVRvKCBpbmRleCApOyAvL0RvIHRoZSBzbGlkZVxuICAgICAgfSxcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaXNTbGlkaW5nKSByZXR1cm47XG4gICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zbGlkZVRvKCBpbmRleCApOyAvL0RvIHRoZSBzbGlkZVxuICAgICAgfSxcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgaXNFbGVtZW50SW5TY3JvbGxSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50W2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKSxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IGdsb2JhbE9iamVjdFtpbm5lckhlaWdodF0gfHwgSFRNTFtjbGllbnRIZWlnaHRdXG4gICAgICAgIHJldHVybiByZWN0W3RvcF0gPD0gdmlld3BvcnRIZWlnaHQgJiYgcmVjdFtib3R0b21dID49IDA7IC8vIGJvdHRvbSAmJiB0b3BcbiAgICAgIH0sICAgIFxuICAgICAgc2V0QWN0aXZlUGFnZSA9IGZ1bmN0aW9uKCBwYWdlSW5kZXggKSB7IC8vaW5kaWNhdG9yc1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGljbCA9IGluZGljYXRvcnNbbGVuZ3RoXTsgaSA8IGljbDsgaSsrICkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGluZGljYXRvcnNbaV0sYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kaWNhdG9yc1twYWdlSW5kZXhdKSBhZGRDbGFzcyhpbmRpY2F0b3JzW3BhZ2VJbmRleF0sIGFjdGl2ZSk7XG4gICAgICB9O1xuICBcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICBpc0VsZW1lbnRJblNjcm9sbFJhbmdlKCkgJiYgKGluZGV4KyssIHNlbGYuc2xpZGVUbyggaW5kZXggKSApO1xuICAgICAgfSwgdGhpc1tpbnRlcnZhbF0pO1xuICAgIH07XG4gICAgdGhpcy5zbGlkZVRvID0gZnVuY3Rpb24oIG5leHQgKSB7XG4gICAgICBpZiAoaXNTbGlkaW5nKSByZXR1cm47IC8vIHdoZW4gY29udHJvbGVkIHZpYSBtZXRob2RzLCBtYWtlIHN1cmUgdG8gY2hlY2sgYWdhaW4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLmdldEFjdGl2ZUluZGV4KCksIC8vIHRoZSBjdXJyZW50IGFjdGl2ZVxuICAgICAgICAgIG9yaWVudGF0aW9uO1xuICAgICAgXG4gICAgICAvLyBkZXRlcm1pbmUgc2xpZGVEaXJlY3Rpb24gZmlyc3RcbiAgICAgIGlmICAoIChhY3RpdmVJdGVtIDwgbmV4dCApIHx8IChhY3RpdmVJdGVtID09PSAwICYmIG5leHQgPT09IHRvdGFsIC0xICkgKSB7XG4gICAgICAgIHNsaWRlRGlyZWN0aW9uID0gc2VsZltkaXJlY3Rpb25dID0gbGVmdDsgLy8gbmV4dFxuICAgICAgfSBlbHNlIGlmICAoIChhY3RpdmVJdGVtID4gbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IHRvdGFsIC0gMSAmJiBuZXh0ID09PSAwICkgKSB7XG4gICAgICAgIHNsaWRlRGlyZWN0aW9uID0gc2VsZltkaXJlY3Rpb25dID0gcmlnaHQ7IC8vIHByZXZcbiAgICAgIH1cbiAgXG4gICAgICAvLyBmaW5kIHRoZSByaWdodCBuZXh0IGluZGV4IFxuICAgICAgaWYgKCBuZXh0IDwgMCApIHsgbmV4dCA9IHRvdGFsIC0gMTsgfSBcbiAgICAgIGVsc2UgaWYgKCBuZXh0ID09PSB0b3RhbCApeyBuZXh0ID0gMDsgfVxuICBcbiAgICAgIC8vIHVwZGF0ZSBpbmRleFxuICAgICAgaW5kZXggPSBuZXh0O1xuICBcbiAgICAgIG9yaWVudGF0aW9uID0gc2xpZGVEaXJlY3Rpb24gPT09IGxlZnQgPyAnbmV4dCcgOiAncHJldic7IC8vZGV0ZXJtaW5lIHR5cGVcbiAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZGVFdmVudCwgY29tcG9uZW50LCBzbGlkZXNbbmV4dF0pOyAvLyBoZXJlIHdlIGdvIHdpdGggdGhlIHNsaWRlXG4gIFxuICAgICAgaXNTbGlkaW5nID0gdHJ1ZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgc2V0QWN0aXZlUGFnZSggbmV4dCApO1xuICBcbiAgICAgIGlmICggc3VwcG9ydFRyYW5zaXRpb25zICYmIGhhc0NsYXNzKGVsZW1lbnQsJ3NsaWRlJykgKSB7XG4gIFxuICAgICAgICBhZGRDbGFzcyhzbGlkZXNbbmV4dF0sY2Fyb3VzZWxJdGVtICsnLScrIG9yaWVudGF0aW9uKTtcbiAgICAgICAgc2xpZGVzW25leHRdW29mZnNldFdpZHRoXTtcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGNhcm91c2VsSXRlbSArJy0nKyBzbGlkZURpcmVjdGlvbik7XG4gICAgICAgIGFkZENsYXNzKHNsaWRlc1thY3RpdmVJdGVtXSxjYXJvdXNlbEl0ZW0gKyctJysgc2xpZGVEaXJlY3Rpb24pO1xuICBcbiAgICAgICAgb25lKHNsaWRlc1thY3RpdmVJdGVtXSwgdHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBlW3RhcmdldF0gIT09IHNsaWRlc1thY3RpdmVJdGVtXSA/IGUuZWxhcHNlZFRpbWUqMTAwMCA6IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaXNTbGlkaW5nID0gZmFsc2U7XG4gIFxuICAgICAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGFjdGl2ZSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sYWN0aXZlKTtcbiAgXG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbbmV4dF0sY2Fyb3VzZWxJdGVtICsnLScrIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlc1tuZXh0XSxjYXJvdXNlbEl0ZW0gKyctJysgc2xpZGVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGVzW2FjdGl2ZUl0ZW1dLGNhcm91c2VsSXRlbSArJy0nKyBzbGlkZURpcmVjdGlvbik7XG4gIFxuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcbiAgXG4gICAgICAgICAgICBpZiAoICFET0MuaGlkZGVuICYmIHNlbGZbaW50ZXJ2YWxdICYmICFoYXNDbGFzcyhlbGVtZW50LHBhdXNlZCkgKSB7XG4gICAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LHRpbWVvdXQrMTAwKTtcbiAgICAgICAgfSk7XG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGFjdGl2ZSk7XG4gICAgICAgIHNsaWRlc1tuZXh0XVtvZmZzZXRXaWR0aF07XG4gICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlc1thY3RpdmVJdGVtXSxhY3RpdmUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICggc2VsZltpbnRlcnZhbF0gJiYgIWhhc0NsYXNzKGVsZW1lbnQscGF1c2VkKSApIHtcbiAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcbiAgICAgICAgfSwgMTAwICk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldEFjdGl2ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNsaWRlc1tpbmRleE9mXShnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsY2Fyb3VzZWxJdGVtKycgYWN0aXZlJylbMF0pIHx8IDA7XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdDYXJvdXNlbCBpbiBlbGVtZW50ICkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gIFxuICAgICAgaWYgKCBzZWxmW3BhdXNlXSAmJiBzZWxmW2ludGVydmFsXSApIHtcbiAgICAgICAgb24oIGVsZW1lbnQsIG1vdXNlSG92ZXJbMF0sIHBhdXNlSGFuZGxlciApO1xuICAgICAgICBvbiggZWxlbWVudCwgbW91c2VIb3ZlclsxXSwgcmVzdW1lSGFuZGxlciApO1xuICAgICAgICBvbiggZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCBwYXVzZUhhbmRsZXIgKTtcbiAgICAgICAgb24oIGVsZW1lbnQsICd0b3VjaGVuZCcsIHJlc3VtZUhhbmRsZXIgKTtcbiAgICAgIH1cbiAgICBcbiAgICAgIHJpZ2h0QXJyb3cgJiYgb24oIHJpZ2h0QXJyb3csIGNsaWNrRXZlbnQsIGNvbnRyb2xzSGFuZGxlciApO1xuICAgICAgbGVmdEFycm93ICYmIG9uKCBsZWZ0QXJyb3csIGNsaWNrRXZlbnQsIGNvbnRyb2xzSGFuZGxlciApO1xuICAgIFxuICAgICAgaW5kaWNhdG9yICYmIG9uKCBpbmRpY2F0b3IsIGNsaWNrRXZlbnQsIGluZGljYXRvckhhbmRsZXIgKTtcbiAgICAgIHNlbGZba2V5Ym9hcmRdID09PSB0cnVlICYmIG9uKCBnbG9iYWxPYmplY3QsIGtleWRvd25FdmVudCwga2V5SGFuZGxlciApO1xuICAgIH1cbiAgICBpZiAoc2VsZi5nZXRBY3RpdmVJbmRleCgpPDApIHtcbiAgICAgIHNsaWRlc1tsZW5ndGhdICYmIGFkZENsYXNzKHNsaWRlc1swXSxhY3RpdmUpO1xuICAgICAgaW5kaWNhdG9yc1tsZW5ndGhdICYmIHNldEFjdGl2ZVBhZ2UoMCk7XG4gICAgfVxuICBcbiAgICBpZiAoIHNlbGZbaW50ZXJ2YWxdICl7IHNlbGYuY3ljbGUoKTsgfVxuICAgIGVsZW1lbnRbc3RyaW5nQ2Fyb3VzZWxdID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIENBUk9VU0VMIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ0Nhcm91c2VsLCBDYXJvdXNlbCwgJ1snK2RhdGFSaWRlKyc9XCJjYXJvdXNlbFwiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IENvbGxhcHNlXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIENPTExBUFNFIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgIC8vIGV2ZW50IHRhcmdldHMgYW5kIGNvbnN0YW50c1xuICAgIHZhciBhY2NvcmRpb24gPSBudWxsLCBjb2xsYXBzZSA9IG51bGwsIHNlbGYgPSB0aGlzLCBcbiAgICAgIGlzQW5pbWF0aW5nID0gZmFsc2UsIC8vIHdoZW4gdHJ1ZSBpdCB3aWxsIHByZXZlbnQgY2xpY2sgaGFuZGxlcnNcbiAgICAgIGFjY29yZGlvbkRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2RhdGEtcGFyZW50JyksXG4gIFxuICAgICAgLy8gY29tcG9uZW50IHN0cmluZ3NcbiAgICAgIGNvbXBvbmVudCA9ICdjb2xsYXBzZScsXG4gICAgICBjb2xsYXBzZWQgPSAnY29sbGFwc2VkJyxcbiAgXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIG9wZW5BY3Rpb24gPSBmdW5jdGlvbihjb2xsYXBzZUVsZW1lbnQsdG9nZ2xlKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93RXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIGlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkQ2xhc3MoY29sbGFwc2VFbGVtZW50LGNvbGxhcHNpbmcpO1xuICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsY29tcG9uZW50KTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gY29sbGFwc2VFbGVtZW50W3Njcm9sbEhlaWdodF0gKyAncHgnO1xuICAgICAgICBcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoY29sbGFwc2VFbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwndHJ1ZScpO1xuICAgICAgICAgIHRvZ2dsZVtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwndHJ1ZScpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbGxhcHNlRWxlbWVudCxjb2xsYXBzaW5nKTtcbiAgICAgICAgICBhZGRDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgYWRkQ2xhc3MoY29sbGFwc2VFbGVtZW50LHNob3dDbGFzcyk7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gJyc7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNsb3NlQWN0aW9uID0gZnVuY3Rpb24oY29sbGFwc2VFbGVtZW50LHRvZ2dsZSkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZUV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICBpc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9IGNvbGxhcHNlRWxlbWVudFtzY3JvbGxIZWlnaHRdICsgJ3B4JzsgLy8gc2V0IGhlaWdodCBmaXJzdFxuICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsY29tcG9uZW50KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoY29sbGFwc2VFbGVtZW50LHNob3dDbGFzcyk7XG4gICAgICAgIGFkZENsYXNzKGNvbGxhcHNlRWxlbWVudCxjb2xsYXBzaW5nKTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50W29mZnNldFdpZHRoXTsgLy8gZm9yY2UgcmVmbG93IHRvIGVuYWJsZSB0cmFuc2l0aW9uXG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9ICcwcHgnO1xuICAgICAgICBcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoY29sbGFwc2VFbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwnZmFsc2UnKTtcbiAgICAgICAgICB0b2dnbGVbc2V0QXR0cmlidXRlXShhcmlhRXhwYW5kZWQsJ2ZhbHNlJyk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoY29sbGFwc2VFbGVtZW50LGNvbGxhcHNpbmcpO1xuICAgICAgICAgIGFkZENsYXNzKGNvbGxhcHNlRWxlbWVudCxjb21wb25lbnQpO1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9ICcnO1xuICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocmVmID0gZWxlbWVudC5ocmVmICYmIGVsZW1lbnRbZ2V0QXR0cmlidXRlXSgnaHJlZicpLFxuICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGFyZ2V0KSxcbiAgICAgICAgICBpZCA9IGhyZWYgfHwgKCBwYXJlbnQgJiYgcGFyZW50LmNoYXJBdCgwKSA9PT0gJyMnICkgJiYgcGFyZW50O1xuICAgICAgICByZXR1cm4gaWQgJiYgcXVlcnlFbGVtZW50KGlkKTtcbiAgICAgIH07XG4gICAgXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGVbcHJldmVudERlZmF1bHRdKCk7XG4gICAgICBpZiAoaXNBbmltYXRpbmcpIHJldHVybjtcbiAgICAgIGlmICghaGFzQ2xhc3MoY29sbGFwc2Usc2hvd0NsYXNzKSkgeyBzZWxmLnNob3coKTsgfSBcbiAgICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbG9zZUFjdGlvbihjb2xsYXBzZSxlbGVtZW50KTtcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsY29sbGFwc2VkKTtcbiAgICB9O1xuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCBhY2NvcmRpb24gKSB7XG4gICAgICAgIHZhciBhY3RpdmVDb2xsYXBzZSA9IHF1ZXJ5RWxlbWVudCgnLicrY29tcG9uZW50KycuJytzaG93Q2xhc3MsYWNjb3JkaW9uKSxcbiAgICAgICAgICAgIHRvZ2dsZSA9IGFjdGl2ZUNvbGxhcHNlICYmIChxdWVyeUVsZW1lbnQoJ1snK2RhdGFUb2dnbGUrJz1cIicrY29tcG9uZW50KydcIl1bJytkYXRhVGFyZ2V0Kyc9XCIjJythY3RpdmVDb2xsYXBzZS5pZCsnXCJdJyxhY2NvcmRpb24pXG4gICAgICAgICAgICAgICAgICAgfHwgcXVlcnlFbGVtZW50KCdbJytkYXRhVG9nZ2xlKyc9XCInK2NvbXBvbmVudCsnXCJdW2hyZWY9XCIjJythY3RpdmVDb2xsYXBzZS5pZCsnXCJdJyxhY2NvcmRpb24pICksXG4gICAgICAgICAgICBjb3JyZXNwb25kaW5nQ29sbGFwc2UgPSB0b2dnbGUgJiYgKHRvZ2dsZVtnZXRBdHRyaWJ1dGVdKGRhdGFUYXJnZXQpIHx8IHRvZ2dsZS5ocmVmKTtcbiAgICAgICAgaWYgKCBhY3RpdmVDb2xsYXBzZSAmJiB0b2dnbGUgJiYgYWN0aXZlQ29sbGFwc2UgIT09IGNvbGxhcHNlICkge1xuICAgICAgICAgIGNsb3NlQWN0aW9uKGFjdGl2ZUNvbGxhcHNlLHRvZ2dsZSk7IFxuICAgICAgICAgIGlmICggY29ycmVzcG9uZGluZ0NvbGxhcHNlLnNwbGl0KCcjJylbMV0gIT09IGNvbGxhcHNlLmlkICkgeyBhZGRDbGFzcyh0b2dnbGUsY29sbGFwc2VkKTsgfSBcbiAgICAgICAgICBlbHNlIHsgcmVtb3ZlQ2xhc3ModG9nZ2xlLGNvbGxhcHNlZCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIG9wZW5BY3Rpb24oY29sbGFwc2UsZWxlbWVudCk7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LGNvbGxhcHNlZCk7XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdDb2xsYXBzZSBpbiBlbGVtZW50ICkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBzZWxmLnRvZ2dsZSk7XG4gICAgfVxuICAgIGNvbGxhcHNlID0gZ2V0VGFyZ2V0KCk7XG4gICAgYWNjb3JkaW9uID0gcXVlcnlFbGVtZW50KG9wdGlvbnMucGFyZW50KSB8fCBhY2NvcmRpb25EYXRhICYmIGdldENsb3Nlc3QoZWxlbWVudCwgYWNjb3JkaW9uRGF0YSk7XG4gICAgZWxlbWVudFtzdHJpbmdDb2xsYXBzZV0gPSBzZWxmO1xuICB9O1xuICBcbiAgLy8gQ09MTEFQU0UgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cbiAgc3VwcG9ydHNbcHVzaF0oIFsgc3RyaW5nQ29sbGFwc2UsIENvbGxhcHNlLCAnWycrZGF0YVRvZ2dsZSsnPVwiY29sbGFwc2VcIl0nIF0gKTtcbiAgXG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBEcm9wZG93blxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIERST1BET1dOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9uICkge1xuICAgICAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIHNldCBvcHRpb25cbiAgICB0aGlzLnBlcnNpc3QgPSBvcHRpb24gPT09IHRydWUgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKCdkYXRhLXBlcnNpc3QnKSA9PT0gJ3RydWUnIHx8IGZhbHNlO1xuICBcbiAgICAvLyBjb25zdGFudHMsIGV2ZW50IHRhcmdldHMsIHN0cmluZ3NcbiAgICB2YXIgc2VsZiA9IHRoaXMsIGNoaWxkcmVuID0gJ2NoaWxkcmVuJyxcbiAgICAgIHBhcmVudCA9IGVsZW1lbnRbcGFyZW50Tm9kZV0sXG4gICAgICBjb21wb25lbnQgPSAnZHJvcGRvd24nLCBvcGVuID0gJ29wZW4nLFxuICAgICAgcmVsYXRlZFRhcmdldCA9IG51bGwsXG4gICAgICBtZW51ID0gcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tbWVudScsIHBhcmVudCksXG4gICAgICBtZW51SXRlbXMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNldCA9IG1lbnVbY2hpbGRyZW5dLCBuZXdTZXQgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGk9MDsgaTxzZXRbbGVuZ3RoXTsgaSsrICl7XG4gICAgICAgICAgc2V0W2ldW2NoaWxkcmVuXVtsZW5ndGhdICYmIChzZXRbaV1bY2hpbGRyZW5dWzBdLnRhZ05hbWUgPT09ICdBJyAmJiBuZXdTZXRbcHVzaF0oc2V0W2ldW2NoaWxkcmVuXVswXSkpO1xuICAgICAgICAgIHNldFtpXS50YWdOYW1lID09PSAnQScgJiYgbmV3U2V0W3B1c2hdKHNldFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICAgIH0pKCksXG4gIFxuICAgICAgLy8gcHJldmVudERlZmF1bHQgb24gZW1wdHkgYW5jaG9yIGxpbmtzXG4gICAgICBwcmV2ZW50RW1wdHlBbmNob3IgPSBmdW5jdGlvbihhbmNob3Ipe1xuICAgICAgICAoYW5jaG9yLmhyZWYgJiYgYW5jaG9yLmhyZWYuc2xpY2UoLTEpID09PSAnIycgfHwgYW5jaG9yW3BhcmVudE5vZGVdICYmIGFuY2hvcltwYXJlbnROb2RlXS5ocmVmIFxuICAgICAgICAgICYmIGFuY2hvcltwYXJlbnROb2RlXS5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnKSAmJiB0aGlzW3ByZXZlbnREZWZhdWx0XSgpOyAgICBcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gdG9nZ2xlIGRpc21pc3NpYmxlIGV2ZW50c1xuICAgICAgdG9nZ2xlRGlzbWlzcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudFtvcGVuXSA/IG9uIDogb2ZmO1xuICAgICAgICB0eXBlKERPQywgY2xpY2tFdmVudCwgZGlzbWlzc0hhbmRsZXIpOyBcbiAgICAgICAgdHlwZShET0MsIGtleWRvd25FdmVudCwgcHJldmVudFNjcm9sbCk7XG4gICAgICAgIHR5cGUoRE9DLCBrZXl1cEV2ZW50LCBrZXlIYW5kbGVyKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gaGFuZGxlcnNcbiAgICAgIGRpc21pc3NIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBlW3RhcmdldF0sIGhhc0RhdGEgPSBldmVudFRhcmdldCAmJiAoc3RyaW5nRHJvcGRvd24gaW4gZXZlbnRUYXJnZXQgfHwgc3RyaW5nRHJvcGRvd24gaW4gZXZlbnRUYXJnZXRbcGFyZW50Tm9kZV0pO1xuICAgICAgICBpZiAoIChldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51W2NvbnRhaW5zXShldmVudFRhcmdldCkpICYmIChzZWxmLnBlcnNpc3QgfHwgaGFzRGF0YSkgKSB7IHJldHVybjsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gZXZlbnRUYXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudFtjb250YWluc10oZXZlbnRUYXJnZXQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsZXZlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgIHNob3coKTtcbiAgICAgICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSxlW3RhcmdldF0pO1xuICAgICAgfSxcbiAgICAgIHByZXZlbnRTY3JvbGwgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgICBpZigga2V5ID09PSAzOCB8fCBrZXkgPT09IDQwICkgeyBlW3ByZXZlbnREZWZhdWx0XSgpOyB9XG4gICAgICB9LFxuICAgICAga2V5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGUsXG4gICAgICAgICAgYWN0aXZlSXRlbSA9IERPQy5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgIGlkeCA9IG1lbnVJdGVtc1tpbmRleE9mXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc1NhbWVFbGVtZW50ID0gYWN0aXZlSXRlbSA9PT0gZWxlbWVudCxcbiAgICAgICAgICBpc0luc2lkZU1lbnUgPSBtZW51W2NvbnRhaW5zXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc01lbnVJdGVtID0gYWN0aXZlSXRlbVtwYXJlbnROb2RlXSA9PT0gbWVudSB8fCBhY3RpdmVJdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdID09PSBtZW51OyAgICAgICAgICBcbiAgXG4gICAgICAgIGlmICggaXNNZW51SXRlbSB8fCBpc1NhbWVFbGVtZW50ICkgeyAvLyBuYXZpZ2F0ZSB1cCB8IGRvd25cbiAgICAgICAgICBpZHggPSBpc1NhbWVFbGVtZW50ID8gMCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5ID09PSAzOCA/IChpZHg+MT9pZHgtMTowKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBrZXkgPT09IDQwID8gKGlkeDxtZW51SXRlbXNbbGVuZ3RoXS0xP2lkeCsxOmlkeCkgOiBpZHg7XG4gICAgICAgICAgbWVudUl0ZW1zW2lkeF0gJiYgc2V0Rm9jdXMobWVudUl0ZW1zW2lkeF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICggKG1lbnVJdGVtc1tsZW5ndGhdICYmIGlzTWVudUl0ZW0gLy8gbWVudSBoYXMgaXRlbXNcbiAgICAgICAgICAgICAgfHwgIW1lbnVJdGVtc1tsZW5ndGhdICYmIChpc0luc2lkZU1lbnUgfHwgaXNTYW1lRWxlbWVudCkgIC8vIG1lbnUgbWlnaHQgYmUgYSBmb3JtXG4gICAgICAgICAgICAgIHx8ICFpc0luc2lkZU1lbnUgKSAvLyBvciB0aGUgZm9jdXNlZCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgbWVudSBhdCBhbGxcbiAgICAgICAgICAgICAgJiYgZWxlbWVudFtvcGVuXSAmJiBrZXkgPT09IDI3ICAvLyBtZW51IG11c3QgYmUgb3BlblxuICAgICAgICApIHtcbiAgICAgICAgICBzZWxmLnRvZ2dsZSgpO1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgc2hvd0V2ZW50LCBjb21wb25lbnQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICBhZGRDbGFzcyhtZW51LHNob3dDbGFzcyk7XG4gICAgICAgIGFkZENsYXNzKHBhcmVudCxzaG93Q2xhc3MpO1xuICAgICAgICBtZW51W3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLHRydWUpO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgc2hvd25FdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgZWxlbWVudFtvcGVuXSA9IHRydWU7XG4gICAgICAgIG9mZihlbGVtZW50LCBjbGlja0V2ZW50LCBjbGlja0hhbmRsZXIpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc2V0Rm9jdXMoIG1lbnVbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKCdJTlBVVCcpWzBdIHx8IGVsZW1lbnQgKTsgLy8gZm9jdXMgdGhlIGZpcnN0IGlucHV0IGl0ZW0gfCBlbGVtZW50XG4gICAgICAgICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgICAgICB9LDEpO1xuICAgICAgfSxcbiAgICAgIGhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIGhpZGVFdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobWVudSxzaG93Q2xhc3MpO1xuICAgICAgICByZW1vdmVDbGFzcyhwYXJlbnQsc2hvd0NsYXNzKTtcbiAgICAgICAgbWVudVtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCxmYWxzZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgZWxlbWVudFtvcGVuXSA9IGZhbHNlO1xuICAgICAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgICAgIHNldEZvY3VzKGVsZW1lbnQpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7IH0sMSk7XG4gICAgICB9O1xuICBcbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSB0byBjbG9zZWRcbiAgICBlbGVtZW50W29wZW5dID0gZmFsc2U7XG4gIFxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChoYXNDbGFzcyhwYXJlbnQsc2hvd0NsYXNzKSAmJiBlbGVtZW50W29wZW5dKSB7IGhpZGUoKTsgfSBcbiAgICAgIGVsc2UgeyBzaG93KCk7IH1cbiAgICB9O1xuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ0Ryb3Bkb3duIGluIGVsZW1lbnQpICkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgIXRhYmluZGV4IGluIG1lbnUgJiYgbWVudVtzZXRBdHRyaWJ1dGVdKHRhYmluZGV4LCAnMCcpOyAvLyBGaXggb25ibHVyIG9uIENocm9tZSB8IFNhZmFyaVxuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gIFxuICAgIGVsZW1lbnRbc3RyaW5nRHJvcGRvd25dID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIERST1BET1dOIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbc3RyaW5nRHJvcGRvd24sIERyb3Bkb3duLCAnWycrZGF0YVRvZ2dsZSsnPVwiZHJvcGRvd25cIl0nXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IE1vZGFsXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gTU9EQUwgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT1cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykgeyAvLyBlbGVtZW50IGNhbiBiZSB0aGUgbW9kYWwvdHJpZ2dlcmluZyBidXR0b25cbiAgXG4gICAgLy8gdGhlIG1vZGFsIChib3RoIEphdmFTY3JpcHQgLyBEQVRBIEFQSSBpbml0KSAvIHRyaWdnZXJpbmcgYnV0dG9uIGVsZW1lbnQgKERBVEEgQVBJKVxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIGRldGVybWluZSBtb2RhbCwgdHJpZ2dlcmluZyBlbGVtZW50XG4gICAgdmFyIGJ0bkNoZWNrID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUYXJnZXQpfHxlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSxcbiAgICAgIGNoZWNrTW9kYWwgPSBxdWVyeUVsZW1lbnQoIGJ0bkNoZWNrICksXG4gICAgICBtb2RhbCA9IGhhc0NsYXNzKGVsZW1lbnQsJ21vZGFsJykgPyBlbGVtZW50IDogY2hlY2tNb2RhbCxcbiAgXG4gICAgICAvLyBzdHJpbmdzXG4gICAgICBjb21wb25lbnQgPSAnbW9kYWwnLFxuICAgICAgc3RhdGljU3RyaW5nID0gJ3N0YXRpYycsXG4gICAgICBwYWRkaW5nTGVmdCA9ICdwYWRkaW5nTGVmdCcsXG4gICAgICBwYWRkaW5nUmlnaHQgPSAncGFkZGluZ1JpZ2h0JyxcbiAgICAgIG1vZGFsQmFja2Ryb3BTdHJpbmcgPSAnbW9kYWwtYmFja2Ryb3AnO1xuICBcbiAgICBpZiAoIGhhc0NsYXNzKGVsZW1lbnQsJ21vZGFsJykgKSB7IGVsZW1lbnQgPSBudWxsOyB9IC8vIG1vZGFsIGlzIG5vdyBpbmRlcGVuZGVudCBvZiBpdCdzIHRyaWdnZXJpbmcgZWxlbWVudFxuICBcbiAgICBpZiAoICFtb2RhbCApIHsgcmV0dXJuOyB9IC8vIGludmFsaWRhdGVcbiAgXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgdGhpc1trZXlib2FyZF0gPSBvcHRpb25zW2tleWJvYXJkXSA9PT0gZmFsc2UgfHwgbW9kYWxbZ2V0QXR0cmlidXRlXShkYXRhS2V5Ym9hcmQpID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIHRoaXNbYmFja2Ryb3BdID0gb3B0aW9uc1tiYWNrZHJvcF0gPT09IHN0YXRpY1N0cmluZyB8fCBtb2RhbFtnZXRBdHRyaWJ1dGVdKGRhdGFiYWNrZHJvcCkgPT09IHN0YXRpY1N0cmluZyA/IHN0YXRpY1N0cmluZyA6IHRydWU7XG4gICAgdGhpc1tiYWNrZHJvcF0gPSBvcHRpb25zW2JhY2tkcm9wXSA9PT0gZmFsc2UgfHwgbW9kYWxbZ2V0QXR0cmlidXRlXShkYXRhYmFja2Ryb3ApID09PSAnZmFsc2UnID8gZmFsc2UgOiB0aGlzW2JhY2tkcm9wXTtcbiAgICB0aGlzW2NvbnRlbnRdICA9IG9wdGlvbnNbY29udGVudF07IC8vIEphdmFTY3JpcHQgb25seVxuICBcbiAgICAvLyBiaW5kLCBjb25zdGFudHMsIGV2ZW50IHRhcmdldHMgYW5kIG90aGVyIHZhcnNcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHJlbGF0ZWRUYXJnZXQgPSBudWxsLFxuICAgICAgYm9keUlzT3ZlcmZsb3dpbmcsIG1vZGFsSXNPdmVyZmxvd2luZywgc2Nyb2xsYmFyV2lkdGgsIG92ZXJsYXksXG4gIFxuICAgICAgLy8gYWxzbyBmaW5kIGZpeGVkLXRvcCAvIGZpeGVkLWJvdHRvbSBpdGVtc1xuICAgICAgZml4ZWRJdGVtcyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoSFRNTCxmaXhlZFRvcCkuY29uY2F0KGdldEVsZW1lbnRzQnlDbGFzc05hbWUoSFRNTCxmaXhlZEJvdHRvbSkpLFxuICBcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgZ2V0V2luZG93V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWxSZWN0ID0gSFRNTFtnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCk7XG4gICAgICAgIHJldHVybiBnbG9iYWxPYmplY3RbaW5uZXJXaWR0aF0gfHwgKGh0bWxSZWN0W3JpZ2h0XSAtIE1hdGguYWJzKGh0bWxSZWN0W2xlZnRdKSk7XG4gICAgICB9LFxuICAgICAgc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keVN0eWxlID0gZ2xvYmFsT2JqZWN0LmdldENvbXB1dGVkU3R5bGUoRE9DW2JvZHldKSxcbiAgICAgICAgICAgIGJvZHlQYWQgPSBwYXJzZUludCgoYm9keVN0eWxlW3BhZGRpbmdSaWdodF0pLCAxMCksIGl0ZW1QYWQ7XG4gICAgICAgIGlmIChib2R5SXNPdmVyZmxvd2luZykge1xuICAgICAgICAgIERPQ1tib2R5XVtzdHlsZV1bcGFkZGluZ1JpZ2h0XSA9IChib2R5UGFkICsgc2Nyb2xsYmFyV2lkdGgpICsgJ3B4JztcbiAgICAgICAgICBpZiAoZml4ZWRJdGVtc1tsZW5ndGhdKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZml4ZWRJdGVtc1tsZW5ndGhdOyBpKyspIHtcbiAgICAgICAgICAgICAgaXRlbVBhZCA9IGdsb2JhbE9iamVjdC5nZXRDb21wdXRlZFN0eWxlKGZpeGVkSXRlbXNbaV0pW3BhZGRpbmdSaWdodF07XG4gICAgICAgICAgICAgIGZpeGVkSXRlbXNbaV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAoIHBhcnNlSW50KGl0ZW1QYWQpICsgc2Nyb2xsYmFyV2lkdGgpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRE9DW2JvZHldW3N0eWxlXVtwYWRkaW5nUmlnaHRdID0gJyc7XG4gICAgICAgIGlmIChmaXhlZEl0ZW1zW2xlbmd0aF0pe1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZml4ZWRJdGVtc1tsZW5ndGhdOyBpKyspIHtcbiAgICAgICAgICAgIGZpeGVkSXRlbXNbaV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICAgICAgdmFyIHNjcm9sbERpdiA9IERPQ1tjcmVhdGVFbGVtZW50XSgnZGl2JyksIHNjcm9sbEJhcldpZHRoO1xuICAgICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gY29tcG9uZW50Kyctc2Nyb2xsYmFyLW1lYXN1cmUnOyAvLyB0aGlzIGlzIGhlcmUgdG8gc3RheVxuICAgICAgICBET0NbYm9keV1bYXBwZW5kQ2hpbGRdKHNjcm9sbERpdik7XG4gICAgICAgIHNjcm9sbEJhcldpZHRoID0gc2Nyb2xsRGl2W29mZnNldFdpZHRoXSAtIHNjcm9sbERpdltjbGllbnRXaWR0aF07XG4gICAgICAgIERPQ1tib2R5XS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQmFyV2lkdGg7XG4gICAgICB9LFxuICAgICAgY2hlY2tTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJvZHlJc092ZXJmbG93aW5nID0gRE9DW2JvZHldW2NsaWVudFdpZHRoXSA8IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgIG1vZGFsSXNPdmVyZmxvd2luZyA9IG1vZGFsW3Njcm9sbEhlaWdodF0gPiBIVE1MW2NsaWVudEhlaWdodF07XG4gICAgICAgIHNjcm9sbGJhcldpZHRoID0gbWVhc3VyZVNjcm9sbGJhcigpO1xuICAgICAgfSxcbiAgICAgIGFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kYWxbc3R5bGVdW3BhZGRpbmdMZWZ0XSA9ICFib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyBzY3JvbGxiYXJXaWR0aCArICdweCcgOiAnJztcbiAgICAgICAgbW9kYWxbc3R5bGVdW3BhZGRpbmdSaWdodF0gPSBib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gc2Nyb2xsYmFyV2lkdGggKyAncHgnIDogJyc7XG4gICAgICB9LFxuICAgICAgcmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kYWxbc3R5bGVdW3BhZGRpbmdMZWZ0XSA9ICcnO1xuICAgICAgICBtb2RhbFtzdHlsZV1bcGFkZGluZ1JpZ2h0XSA9ICcnO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kYWxPdmVybGF5ID0gMTsgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIG5ld092ZXJsYXkgPSBET0NbY3JlYXRlRWxlbWVudF0oJ2RpdicpO1xuICAgICAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcuJyttb2RhbEJhY2tkcm9wU3RyaW5nKTtcbiAgXG4gICAgICAgIGlmICggb3ZlcmxheSA9PT0gbnVsbCApIHtcbiAgICAgICAgICBuZXdPdmVybGF5W3NldEF0dHJpYnV0ZV0oJ2NsYXNzJyxtb2RhbEJhY2tkcm9wU3RyaW5nKycgZmFkZScpO1xuICAgICAgICAgIG92ZXJsYXkgPSBuZXdPdmVybGF5O1xuICAgICAgICAgIERPQ1tib2R5XVthcHBlbmRDaGlsZF0ob3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy4nK21vZGFsQmFja2Ryb3BTdHJpbmcpO1xuICAgICAgICBpZiAoIG92ZXJsYXkgJiYgb3ZlcmxheSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcmxheSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgbW9kYWxPdmVybGF5ID0gMDsgICAgICAgIFxuICAgICAgICAgIERPQ1tib2R5XS5yZW1vdmVDaGlsZChvdmVybGF5KTsgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCk7ICAgICAgXG4gICAgICB9LFxuICAgICAga2V5ZG93bkhhbmRsZXJUb2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykpIHtcbiAgICAgICAgICBvbihET0MsIGtleWRvd25FdmVudCwga2V5SGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmKERPQywga2V5ZG93bkV2ZW50LCBrZXlIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2l6ZUhhbmRsZXJUb2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykpIHtcbiAgICAgICAgICBvbihnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLnVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmKGdsb2JhbE9iamVjdCwgcmVzaXplRXZlbnQsIHNlbGYudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChoYXNDbGFzcyhtb2RhbCxzaG93Q2xhc3MpKSB7XG4gICAgICAgICAgb24obW9kYWwsIGNsaWNrRXZlbnQsIGRpc21pc3NIYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYobW9kYWwsIGNsaWNrRXZlbnQsIGRpc21pc3NIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICB0cmlnZ2VyU2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRGb2N1cyhtb2RhbCk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3duRXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlckhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kYWxbc3R5bGVdLmRpc3BsYXkgPSAnJztcbiAgICAgICAgZWxlbWVudCAmJiAoc2V0Rm9jdXMoZWxlbWVudCkpO1xuICAgICAgICBcbiAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYgKCFnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKERPQyxjb21wb25lbnQrJyAnK3Nob3dDbGFzcylbMF0pIHtcbiAgICAgICAgICAgIHJlc2V0QWRqdXN0bWVudHMoKTtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhET0NbYm9keV0sY29tcG9uZW50Kyctb3BlbicpO1xuICAgICAgICAgICAgb3ZlcmxheSAmJiBoYXNDbGFzcyhvdmVybGF5LCdmYWRlJykgPyAocmVtb3ZlQ2xhc3Mob3ZlcmxheSxzaG93Q2xhc3MpLCBlbXVsYXRlVHJhbnNpdGlvbkVuZChvdmVybGF5LHJlbW92ZU92ZXJsYXkpKSBcbiAgICAgICAgICAgIDogcmVtb3ZlT3ZlcmxheSgpO1xuICBcbiAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXJUb2dnbGUoKTtcbiAgICAgICAgICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlKCk7XG4gICAgICAgICAgICBrZXlkb3duSGFuZGxlclRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpKTtcbiAgICAgIH0sXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlW3RhcmdldF07XG4gICAgICAgIGNsaWNrVGFyZ2V0ID0gY2xpY2tUYXJnZXRbaGFzQXR0cmlidXRlXShkYXRhVGFyZ2V0KSB8fCBjbGlja1RhcmdldFtoYXNBdHRyaWJ1dGVdKCdocmVmJykgPyBjbGlja1RhcmdldCA6IGNsaWNrVGFyZ2V0W3BhcmVudE5vZGVdO1xuICAgICAgICBpZiAoIGNsaWNrVGFyZ2V0ID09PSBlbGVtZW50ICYmICFoYXNDbGFzcyhtb2RhbCxzaG93Q2xhc3MpICkge1xuICAgICAgICAgIG1vZGFsLm1vZGFsVHJpZ2dlciA9IGVsZW1lbnQ7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChzZWxmW2tleWJvYXJkXSAmJiBlLndoaWNoID09IDI3ICYmIGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykpIHtcbiAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc21pc3NIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlW3RhcmdldF07XG4gICAgICAgIGlmICggaGFzQ2xhc3MobW9kYWwsc2hvd0NsYXNzKSAmJiAoY2xpY2tUYXJnZXRbcGFyZW50Tm9kZV1bZ2V0QXR0cmlidXRlXShkYXRhRGlzbWlzcykgPT09IGNvbXBvbmVudFxuICAgICAgICAgICAgfHwgY2xpY2tUYXJnZXRbZ2V0QXR0cmlidXRlXShkYXRhRGlzbWlzcykgPT09IGNvbXBvbmVudFxuICAgICAgICAgICAgfHwgKGNsaWNrVGFyZ2V0ID09PSBtb2RhbCAmJiBzZWxmW2JhY2tkcm9wXSAhPT0gc3RhdGljU3RyaW5nKSApICkge1xuICAgICAgICAgIHNlbGYuaGlkZSgpOyByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICBcbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykgKSB7dGhpcy5oaWRlKCk7fSBlbHNlIHt0aGlzLnNob3coKTt9XG4gICAgfTtcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3dFdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgXG4gICAgICAvLyB3ZSBlbGVnYW50bHkgaGlkZSBhbnkgb3BlbmVkIG1vZGFsXG4gICAgICB2YXIgY3VycmVudE9wZW4gPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKERPQyxjb21wb25lbnQrJyAnK3Nob3dDbGFzcylbMF07XG4gICAgICBjdXJyZW50T3BlbiAmJiBjdXJyZW50T3BlbiAhPT0gbW9kYWwgJiYgY3VycmVudE9wZW4ubW9kYWxUcmlnZ2VyW3N0cmluZ01vZGFsXS5oaWRlKCk7XG4gIFxuICAgICAgaWYgKCB0aGlzW2JhY2tkcm9wXSApIHtcbiAgICAgICAgIW1vZGFsT3ZlcmxheSAmJiBjcmVhdGVPdmVybGF5KCk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCBvdmVybGF5ICYmIG1vZGFsT3ZlcmxheSAmJiAhaGFzQ2xhc3Mob3ZlcmxheSxzaG93Q2xhc3MpKSB7XG4gICAgICAgIG92ZXJsYXlbb2Zmc2V0V2lkdGhdOyAvLyBmb3JjZSByZWZsb3cgdG8gZW5hYmxlIHRyYXNpdGlvblxuICAgICAgICBhZGRDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpO1xuICAgICAgfVxuICBcbiAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2RhbFtzdHlsZV0uZGlzcGxheSA9ICdibG9jayc7XG4gIFxuICAgICAgICBjaGVja1Njcm9sbGJhcigpO1xuICAgICAgICBzZXRTY3JvbGxiYXIoKTtcbiAgICAgICAgYWRqdXN0RGlhbG9nKCk7XG4gIFxuICAgICAgICBhZGRDbGFzcyhET0NbYm9keV0sY29tcG9uZW50Kyctb3BlbicpO1xuICAgICAgICBhZGRDbGFzcyhtb2RhbCxzaG93Q2xhc3MpO1xuICAgICAgICBtb2RhbFtzZXRBdHRyaWJ1dGVdKGFyaWFIaWRkZW4sIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIHJlc2l6ZUhhbmRsZXJUb2dnbGUoKTtcbiAgICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUoKTtcbiAgICAgICAga2V5ZG93bkhhbmRsZXJUb2dnbGUoKTtcbiAgXG4gICAgICAgIGhhc0NsYXNzKG1vZGFsLCdmYWRlJykgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlclNob3cpIDogdHJpZ2dlclNob3coKTtcbiAgICAgIH0sIHN1cHBvcnRUcmFuc2l0aW9ucyA/IDE1MCA6IDApO1xuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBoaWRlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcuJyttb2RhbEJhY2tkcm9wU3RyaW5nKTtcbiAgXG4gICAgICByZW1vdmVDbGFzcyhtb2RhbCxzaG93Q2xhc3MpO1xuICAgICAgbW9kYWxbc2V0QXR0cmlidXRlXShhcmlhSGlkZGVuLCB0cnVlKTtcbiAgXG4gICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgaGFzQ2xhc3MobW9kYWwsJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsLCB0cmlnZ2VySGlkZSkgOiB0cmlnZ2VySGlkZSgpO1xuICAgICAgfSgpKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0Q29udGVudCA9IGZ1bmN0aW9uKCBjb250ZW50ICkge1xuICAgICAgcXVlcnlFbGVtZW50KCcuJytjb21wb25lbnQrJy1jb250ZW50Jyxtb2RhbClbaW5uZXJIVE1MXSA9IGNvbnRlbnQ7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykpIHtcbiAgICAgICAgY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgIGFkanVzdERpYWxvZygpO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyBvdmVyIGFuZCBvdmVyXG4gICAgLy8gbW9kYWwgaXMgaW5kZXBlbmRlbnQgb2YgYSB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICBpZiAoICEhZWxlbWVudCAmJiAhKHN0cmluZ01vZGFsIGluIGVsZW1lbnQpICkge1xuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKCAhIXNlbGZbY29udGVudF0gKSB7IHNlbGYuc2V0Q29udGVudCggc2VsZltjb250ZW50XSApOyB9XG4gICAgISFlbGVtZW50ICYmIChlbGVtZW50W3N0cmluZ01vZGFsXSA9IHNlbGYpO1xuICB9O1xuICBcbiAgLy8gREFUQSBBUElcbiAgc3VwcG9ydHNbcHVzaF0oIFsgc3RyaW5nTW9kYWwsIE1vZGFsLCAnWycrZGF0YVRvZ2dsZSsnPVwibW9kYWxcIl0nIF0gKTtcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFBvcG92ZXJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIFxuICAvLyBQT1BPVkVSIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09XG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0cmlnZ2VyRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVHJpZ2dlciksIC8vIGNsaWNrIC8gaG92ZXIgLyBmb2N1c1xuICAgICAgICBhbmltYXRpb25EYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFBbmltYXRpb24pLCAvLyB0cnVlIC8gZmFsc2VcbiAgICAgICAgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhUGxhY2VtZW50KSxcbiAgICAgICAgZGlzbWlzc2libGVEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEaXNtaXNzaWJsZSksXG4gICAgICAgIGRlbGF5RGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhRGVsYXkpLFxuICAgICAgICBjb250YWluZXJEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFDb250YWluZXIpLFxuICBcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RyaW5nc1xuICAgICAgICBjb21wb25lbnQgPSAncG9wb3ZlcicsXG4gICAgICAgIHRlbXBsYXRlID0gJ3RlbXBsYXRlJyxcbiAgICAgICAgdHJpZ2dlciA9ICd0cmlnZ2VyJyxcbiAgICAgICAgY2xhc3NTdHJpbmcgPSAnY2xhc3MnLFxuICAgICAgICBkaXYgPSAnZGl2JyxcbiAgICAgICAgZmFkZSA9ICdmYWRlJyxcbiAgICAgICAgY29udGVudCA9ICdjb250ZW50JyxcbiAgICAgICAgZGF0YUNvbnRlbnQgPSAnZGF0YS1jb250ZW50JyxcbiAgICAgICAgZGlzbWlzc2libGUgPSAnZGlzbWlzc2libGUnLFxuICAgICAgICBjbG9zZUJ0biA9ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCI+w5c8L2J1dHRvbj4nLFxuICBcbiAgICAgICAgLy8gY2hlY2sgY29udGFpbmVyXG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBxdWVyeUVsZW1lbnQob3B0aW9uc1tjb250YWluZXJdKSxcbiAgICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSksICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gbWF5YmUgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGEgbW9kYWxcbiAgICAgICAgbW9kYWwgPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy5tb2RhbCcpLFxuICAgICAgICBcbiAgICAgICAgLy8gbWF5YmUgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGEgZml4ZWQgbmF2YmFyXG4gICAgICAgIG5hdmJhckZpeGVkVG9wID0gZ2V0Q2xvc2VzdChlbGVtZW50LCcuJytmaXhlZFRvcCksXG4gICAgICAgIG5hdmJhckZpeGVkQm90dG9tID0gZ2V0Q2xvc2VzdChlbGVtZW50LCcuJytmaXhlZEJvdHRvbSk7XG4gIFxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdGhpc1t0ZW1wbGF0ZV0gPSBvcHRpb25zW3RlbXBsYXRlXSA/IG9wdGlvbnNbdGVtcGxhdGVdIDogbnVsbDsgLy8gSmF2YVNjcmlwdCBvbmx5XG4gICAgdGhpc1t0cmlnZ2VyXSA9IG9wdGlvbnNbdHJpZ2dlcl0gPyBvcHRpb25zW3RyaWdnZXJdIDogdHJpZ2dlckRhdGEgfHwgaG92ZXJFdmVudDtcbiAgICB0aGlzW2FuaW1hdGlvbl0gPSBvcHRpb25zW2FuaW1hdGlvbl0gJiYgb3B0aW9uc1thbmltYXRpb25dICE9PSBmYWRlID8gb3B0aW9uc1thbmltYXRpb25dIDogYW5pbWF0aW9uRGF0YSB8fCBmYWRlO1xuICAgIHRoaXNbcGxhY2VtZW50XSA9IG9wdGlvbnNbcGxhY2VtZW50XSA/IG9wdGlvbnNbcGxhY2VtZW50XSA6IHBsYWNlbWVudERhdGEgfHwgdG9wO1xuICAgIHRoaXNbZGVsYXldID0gcGFyc2VJbnQob3B0aW9uc1tkZWxheV0gfHwgZGVsYXlEYXRhKSB8fCAyMDA7XG4gICAgdGhpc1tkaXNtaXNzaWJsZV0gPSBvcHRpb25zW2Rpc21pc3NpYmxlXSB8fCBkaXNtaXNzaWJsZURhdGEgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZTtcbiAgICB0aGlzW2NvbnRhaW5lcl0gPSBjb250YWluZXJFbGVtZW50ID8gY29udGFpbmVyRWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXJEYXRhRWxlbWVudCA/IGNvbnRhaW5lckRhdGFFbGVtZW50IFxuICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkVG9wID8gbmF2YmFyRml4ZWRUb3BcbiAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZEJvdHRvbSA/IG5hdmJhckZpeGVkQm90dG9tXG4gICAgICAgICAgICAgICAgICAgIDogbW9kYWwgPyBtb2RhbCA6IERPQ1tib2R5XTtcbiAgICBcbiAgICAvLyBiaW5kLCBjb250ZW50XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBcbiAgICAgIHRpdGxlU3RyaW5nID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUaXRsZSkgfHwgbnVsbCxcbiAgICAgIGNvbnRlbnRTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRlbnQpIHx8IG51bGw7XG4gIFxuICAgIGlmICggIWNvbnRlbnRTdHJpbmcgJiYgIXRoaXNbdGVtcGxhdGVdICkgcmV0dXJuOyAvLyBpbnZhbGlkYXRlXG4gIFxuICAgIC8vIGNvbnN0YW50cywgdmFyc1xuICAgIHZhciBwb3BvdmVyID0gbnVsbCwgdGltZXIgPSAwLCBwbGFjZW1lbnRTZXR0aW5nID0gdGhpc1twbGFjZW1lbnRdLFxuICAgICAgXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgZGlzbWlzc2libGVIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAocG9wb3ZlciAhPT0gbnVsbCAmJiBlW3RhcmdldF0gPT09IHF1ZXJ5RWxlbWVudCgnLmNsb3NlJyxwb3BvdmVyKSkge1xuICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgcmVtb3ZlUG9wb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmW2NvbnRhaW5lcl0ucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDsgcG9wb3ZlciA9IG51bGw7IFxuICAgICAgfSxcbiAgICAgIGNyZWF0ZVBvcG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGl0bGVTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YVRpdGxlKTsgLy8gY2hlY2sgY29udGVudCBhZ2FpblxuICAgICAgICBjb250ZW50U3RyaW5nID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFDb250ZW50KTtcbiAgXG4gICAgICAgIHBvcG92ZXIgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgXG4gICAgICAgIC8vIHBvcG92ZXIgYXJyb3dcbiAgICAgICAgdmFyIHBvcG92ZXJBcnJvdyA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICBwb3BvdmVyQXJyb3dbc2V0QXR0cmlidXRlXShjbGFzc1N0cmluZywnYXJyb3cnKTtcbiAgICAgICAgcG9wb3ZlclthcHBlbmRDaGlsZF0ocG9wb3ZlckFycm93KTtcbiAgXG4gICAgICAgIGlmICggY29udGVudFN0cmluZyAhPT0gbnVsbCAmJiBzZWxmW3RlbXBsYXRlXSA9PT0gbnVsbCApIHsgLy9jcmVhdGUgdGhlIHBvcG92ZXIgZnJvbSBkYXRhIGF0dHJpYnV0ZXNcbiAgXG4gICAgICAgICAgcG9wb3ZlcltzZXRBdHRyaWJ1dGVdKCdyb2xlJywndG9vbHRpcCcpO1xuICBcbiAgICAgICAgICBpZiAodGl0bGVTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwb3BvdmVyVGl0bGUgPSBET0NbY3JlYXRlRWxlbWVudF0oJ2gzJyk7XG4gICAgICAgICAgICBwb3BvdmVyVGl0bGVbc2V0QXR0cmlidXRlXShjbGFzc1N0cmluZyxjb21wb25lbnQrJy1oZWFkZXInKTtcbiAgXG4gICAgICAgICAgICBwb3BvdmVyVGl0bGVbaW5uZXJIVE1MXSA9IHNlbGZbZGlzbWlzc2libGVdID8gdGl0bGVTdHJpbmcgKyBjbG9zZUJ0biA6IHRpdGxlU3RyaW5nO1xuICAgICAgICAgICAgcG9wb3ZlclthcHBlbmRDaGlsZF0ocG9wb3ZlclRpdGxlKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8vc2V0IHBvcG92ZXIgY29udGVudFxuICAgICAgICAgIHZhciBwb3BvdmVyQ29udGVudCA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICAgIHBvcG92ZXJDb250ZW50W3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsY29tcG9uZW50KyctYm9keScpO1xuICAgICAgICAgIHBvcG92ZXJDb250ZW50W2lubmVySFRNTF0gPSBzZWxmW2Rpc21pc3NpYmxlXSAmJiB0aXRsZVN0cmluZyA9PT0gbnVsbCA/IGNvbnRlbnRTdHJpbmcgKyBjbG9zZUJ0biA6IGNvbnRlbnRTdHJpbmc7XG4gICAgICAgICAgcG9wb3ZlclthcHBlbmRDaGlsZF0ocG9wb3ZlckNvbnRlbnQpO1xuICBcbiAgICAgICAgfSBlbHNlIHsgIC8vIG9yIGNyZWF0ZSB0aGUgcG9wb3ZlciBmcm9tIHRlbXBsYXRlXG4gICAgICAgICAgdmFyIHBvcG92ZXJUZW1wbGF0ZSA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICAgIHBvcG92ZXJUZW1wbGF0ZVtpbm5lckhUTUxdID0gc2VsZlt0ZW1wbGF0ZV07XG4gICAgICAgICAgcG9wb3Zlcltpbm5lckhUTUxdID0gcG9wb3ZlclRlbXBsYXRlLmZpcnN0Q2hpbGRbaW5uZXJIVE1MXTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy9hcHBlbmQgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBzZWxmW2NvbnRhaW5lcl1bYXBwZW5kQ2hpbGRdKHBvcG92ZXIpO1xuICAgICAgICBwb3BvdmVyW3N0eWxlXS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcG9wb3ZlcltzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCBjb21wb25lbnQrICcgYnMtJyArIGNvbXBvbmVudCsnLScrcGxhY2VtZW50U2V0dGluZyArICcgJyArIHNlbGZbYW5pbWF0aW9uXSk7XG4gICAgICB9LFxuICAgICAgc2hvd1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFoYXNDbGFzcyhwb3BvdmVyLHNob3dDbGFzcykgJiYgKCBhZGRDbGFzcyhwb3BvdmVyLHNob3dDbGFzcykgKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVQb3BvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0eWxlVGlwKGVsZW1lbnQscG9wb3ZlcixwbGFjZW1lbnRTZXR0aW5nLHNlbGZbY29udGFpbmVyXSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIGV2ZW50IHRvZ2dsZVxuICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAgICAgaWYgKGNsaWNrRXZlbnQgPT0gc2VsZlt0cmlnZ2VyXSB8fCAnZm9jdXMnID09IHNlbGZbdHJpZ2dlcl0pIHtcbiAgICAgICAgICAhc2VsZltkaXNtaXNzaWJsZV0gJiYgdHlwZSggZWxlbWVudCwgJ2JsdXInLCBzZWxmLmhpZGUgKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmW2Rpc21pc3NpYmxlXSAmJiB0eXBlKCBET0MsIGNsaWNrRXZlbnQsIGRpc21pc3NpYmxlSGFuZGxlciApOyAgICAgXG4gICAgICAgIHR5cGUoIGdsb2JhbE9iamVjdCwgcmVzaXplRXZlbnQsIHNlbGYuaGlkZSApO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyB0cmlnZ2Vyc1xuICAgICAgc2hvd1RyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUob24pO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICB9LFxuICAgICAgaGlkZVRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUob2ZmKTtcbiAgICAgICAgcmVtb3ZlUG9wb3ZlcigpO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZHMgLyBoYW5kbGVyc1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkgeyBzZWxmLnNob3coKTsgfSBcbiAgICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICAgIH07XG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBwbGFjZW1lbnRTZXR0aW5nID0gc2VsZltwbGFjZW1lbnRdOyAvLyB3ZSByZXNldCBwbGFjZW1lbnQgaW4gYWxsIGNhc2VzXG4gICAgICAgICAgY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIHVwZGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICBzaG93UG9wb3ZlcigpO1xuICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0V2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICAgICEhc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3Zlciwgc2hvd1RyaWdnZXIpIDogc2hvd1RyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjAgKTtcbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwb3BvdmVyICYmIHBvcG92ZXIgIT09IG51bGwgJiYgaGFzQ2xhc3MocG9wb3ZlcixzaG93Q2xhc3MpKSB7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MocG9wb3ZlcixzaG93Q2xhc3MpO1xuICAgICAgICAgICEhc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3ZlciwgaGlkZVRyaWdnZXIpIDogaGlkZVRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2VsZltkZWxheV0gKTtcbiAgICB9O1xuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ1BvcG92ZXIgaW4gZWxlbWVudCkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBpZiAoc2VsZlt0cmlnZ2VyXSA9PT0gaG92ZXJFdmVudCkge1xuICAgICAgICBvbiggZWxlbWVudCwgbW91c2VIb3ZlclswXSwgc2VsZi5zaG93ICk7XG4gICAgICAgIGlmICghc2VsZltkaXNtaXNzaWJsZV0pIHsgb24oIGVsZW1lbnQsIG1vdXNlSG92ZXJbMV0sIHNlbGYuaGlkZSApOyB9XG4gICAgICB9IGVsc2UgaWYgKGNsaWNrRXZlbnQgPT0gc2VsZlt0cmlnZ2VyXSB8fCAnZm9jdXMnID09IHNlbGZbdHJpZ2dlcl0pIHtcbiAgICAgICAgb24oIGVsZW1lbnQsIHNlbGZbdHJpZ2dlcl0sIHNlbGYudG9nZ2xlICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nUG9wb3Zlcl0gPSBzZWxmO1xuICB9O1xuICBcbiAgLy8gUE9QT1ZFUiBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ1BvcG92ZXIsIFBvcG92ZXIsICdbJytkYXRhVG9nZ2xlKyc9XCJwb3BvdmVyXCJdJyBdICk7XG4gIFxuICBcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgU2Nyb2xsU3B5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIFNDUk9MTFNQWSBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG4gIHZhciBTY3JvbGxTcHkgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnQsIHRoZSBlbGVtZW50IHdlIHNweSBvblxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7IFxuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0YXJnZXREYXRhID0gcXVlcnlFbGVtZW50KGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGFyZ2V0KSksXG4gICAgICAgIG9mZnNldERhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2RhdGEtb2Zmc2V0Jyk7XG4gIFxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCAhb3B0aW9uc1t0YXJnZXRdICYmICF0YXJnZXREYXRhICkgeyByZXR1cm47IH0gLy8gaW52YWxpZGF0ZVxuICBcbiAgICAvLyBldmVudCB0YXJnZXRzLCBjb25zdGFudHNcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHNweVRhcmdldCA9IG9wdGlvbnNbdGFyZ2V0XSAmJiBxdWVyeUVsZW1lbnQob3B0aW9uc1t0YXJnZXRdKSB8fCB0YXJnZXREYXRhLFxuICAgICAgICBsaW5rcyA9IHNweVRhcmdldCAmJiBzcHlUYXJnZXRbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKCdBJyksXG4gICAgICAgIG9mZnNldCA9IHBhcnNlSW50KG9mZnNldERhdGEgfHwgb3B0aW9uc1snb2Zmc2V0J10pIHx8IDEwLCAgICAgIFxuICAgICAgICBpdGVtcyA9IFtdLCB0YXJnZXRJdGVtcyA9IFtdLCBzY3JvbGxPZmZzZXQsXG4gICAgICAgIHNjcm9sbFRhcmdldCA9IGVsZW1lbnRbb2Zmc2V0SGVpZ2h0XSA8IGVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSA/IGVsZW1lbnQgOiBnbG9iYWxPYmplY3QsIC8vIGRldGVybWluZSB3aGljaCBpcyB0aGUgcmVhbCBzY3JvbGxUYXJnZXRcbiAgICAgICAgaXNXaW5kb3cgPSBzY3JvbGxUYXJnZXQgPT09IGdsb2JhbE9iamVjdDsgIFxuICBcbiAgICAvLyBwb3B1bGF0ZSBpdGVtcyBhbmQgdGFyZ2V0c1xuICAgIGZvciAodmFyIGk9MCwgaWw9bGlua3NbbGVuZ3RoXTsgaTxpbDsgaSsrKSB7XG4gICAgICB2YXIgaHJlZiA9IGxpbmtzW2ldW2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSwgXG4gICAgICAgICAgdGFyZ2V0SXRlbSA9IGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJyAmJiBocmVmLnNsaWNlKC0xKSAhPT0gJyMnICYmIHF1ZXJ5RWxlbWVudChocmVmKTtcbiAgICAgIGlmICggISF0YXJnZXRJdGVtICkge1xuICAgICAgICBpdGVtc1twdXNoXShsaW5rc1tpXSk7XG4gICAgICAgIHRhcmdldEl0ZW1zW3B1c2hdKHRhcmdldEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgdmFyIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICB0YXJnZXRJdGVtID0gdGFyZ2V0SXRlbXNbaW5kZXhdLCAvLyB0aGUgbWVudSBpdGVtIHRhcmdldHMgdGhpcyBlbGVtZW50XG4gICAgICAgICAgZHJvcGRvd24gPSBpdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdLFxuICAgICAgICAgIGRyb3Bkb3duTGluayA9IGhhc0NsYXNzKGRyb3Bkb3duLCdkcm9wZG93bicpICYmIGRyb3Bkb3duW2dldEVsZW1lbnRzQnlUYWdOYW1lXSgnQScpWzBdLFxuICAgICAgICAgIHRhcmdldFJlY3QgPSBpc1dpbmRvdyAmJiB0YXJnZXRJdGVtW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKSxcbiAgXG4gICAgICAgICAgaXNBY3RpdmUgPSBoYXNDbGFzcyhpdGVtLGFjdGl2ZSkgfHwgZmFsc2UsXG4gIFxuICAgICAgICAgIHRvcEVkZ2UgPSAoaXNXaW5kb3cgPyB0YXJnZXRSZWN0W3RvcF0gKyBzY3JvbGxPZmZzZXQgOiB0YXJnZXRJdGVtW29mZnNldFRvcF0pIC0gb2Zmc2V0LFxuICAgICAgICAgIGJvdHRvbUVkZ2UgPSBpc1dpbmRvdyA/IHRhcmdldFJlY3RbYm90dG9tXSArIHNjcm9sbE9mZnNldCAtIG9mZnNldCA6IHRhcmdldEl0ZW1zW2luZGV4KzFdID8gdGFyZ2V0SXRlbXNbaW5kZXgrMV1bb2Zmc2V0VG9wXSAtIG9mZnNldCA6IGVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSxcbiAgXG4gICAgICAgICAgaW5zaWRlID0gc2Nyb2xsT2Zmc2V0ID49IHRvcEVkZ2UgJiYgYm90dG9tRWRnZSA+IHNjcm9sbE9mZnNldDtcbiAgXG4gICAgICAgIGlmICggIWlzQWN0aXZlICYmIGluc2lkZSApIHtcbiAgICAgICAgICBpZiAoICFoYXNDbGFzcyhpdGVtLGFjdGl2ZSkgKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhpdGVtLGFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25MaW5rICYmICFoYXNDbGFzcyhkcm9wZG93bkxpbmssYWN0aXZlKSApIHtcbiAgICAgICAgICAgICAgYWRkQ2xhc3MoZHJvcGRvd25MaW5rLGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsICdhY3RpdmF0ZScsICdzY3JvbGxzcHknLCBpdGVtc1tpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggIWluc2lkZSApIHtcbiAgICAgICAgICBpZiAoIGhhc0NsYXNzKGl0ZW0sYWN0aXZlKSApIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sYWN0aXZlKTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bkxpbmsgJiYgaGFzQ2xhc3MoZHJvcGRvd25MaW5rLGFjdGl2ZSkgJiYgIWdldEVsZW1lbnRzQnlDbGFzc05hbWUoaXRlbVtwYXJlbnROb2RlXSxhY3RpdmUpLmxlbmd0aCAgKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRyb3Bkb3duTGluayxhY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggIWluc2lkZSAmJiAhaXNBY3RpdmUgfHwgaXNBY3RpdmUgJiYgaW5zaWRlICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUl0ZW1zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gaXNXaW5kb3cgPyBnZXRTY3JvbGwoKS55IDogZWxlbWVudFtzY3JvbGxUb3BdO1xuICAgICAgICBmb3IgKHZhciBpbmRleD0wLCBpdGw9aXRlbXNbbGVuZ3RoXTsgaW5kZXg8aXRsOyBpbmRleCsrKSB7XG4gICAgICAgICAgdXBkYXRlSXRlbShpbmRleClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUl0ZW1zKCk7XG4gICAgfVxuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ1Njcm9sbFNweSBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKCBzY3JvbGxUYXJnZXQsIHNjcm9sbEV2ZW50LCBzZWxmLnJlZnJlc2ggKTtcbiAgICAgIG9uKCBnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLnJlZnJlc2ggKTsgXG4gICAgfVxuICAgIHNlbGYucmVmcmVzaCgpO1xuICAgIGVsZW1lbnRbc3RyaW5nU2Nyb2xsU3B5XSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBTQ1JPTExTUFkgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ1Njcm9sbFNweSwgU2Nyb2xsU3B5LCAnWycrZGF0YVNweSsnPVwic2Nyb2xsXCJdJyBdICk7XG4gIFxuICBcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVGFiXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIFRBQiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09XG4gIHZhciBUYWIgPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIGhlaWdodERhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUhlaWdodCksXG4gICAgICBcbiAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICBjb21wb25lbnQgPSAndGFiJywgaGVpZ2h0ID0gJ2hlaWdodCcsIGZsb2F0ID0gJ2Zsb2F0JywgaXNBbmltYXRpbmcgPSAnaXNBbmltYXRpbmcnO1xuICAgICAgICBcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXNbaGVpZ2h0XSA9IHN1cHBvcnRUcmFuc2l0aW9ucyA/IChvcHRpb25zW2hlaWdodF0gfHwgaGVpZ2h0RGF0YSA9PT0gJ3RydWUnKSA6IGZhbHNlO1xuICBcbiAgICAvLyBiaW5kLCBldmVudCB0YXJnZXRzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBuZXh0LFxuICAgICAgdGFicyA9IGdldENsb3Nlc3QoZWxlbWVudCwnLm5hdicpLFxuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIgPSBmYWxzZSxcbiAgICAgIGRyb3Bkb3duID0gdGFicyAmJiBxdWVyeUVsZW1lbnQoJy5kcm9wZG93bi10b2dnbGUnLHRhYnMpLFxuICAgICAgYWN0aXZlVGFiLCBhY3RpdmVDb250ZW50LCBuZXh0Q29udGVudCwgY29udGFpbmVySGVpZ2h0LCBlcXVhbENvbnRlbnRzLCBuZXh0SGVpZ2h0LFxuICAgICAgXG4gICAgICAvLyB0cmlnZ2VyXG4gICAgICB0cmlnZ2VyRW5kID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXJbc3R5bGVdW2hlaWdodF0gPSAnJztcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGFic0NvbnRlbnRDb250YWluZXIsY29sbGFwc2luZyk7XG4gICAgICAgIHRhYnNbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgICBpZiAoIGVxdWFsQ29udGVudHMgKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRW5kKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgLy8gZW5hYmxlcyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW3N0eWxlXVtoZWlnaHRdID0gbmV4dEhlaWdodCArICdweCc7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXJbb2Zmc2V0V2lkdGhdO1xuICAgICAgICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0YWJzQ29udGVudENvbnRhaW5lciwgdHJpZ2dlckVuZCk7XG4gICAgICAgICAgICB9LDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWJzW2lzQW5pbWF0aW5nXSA9IGZhbHNlOyBcbiAgICAgICAgfVxuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKG5leHQsIHNob3duRXZlbnQsIGNvbXBvbmVudCwgYWN0aXZlVGFiKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VySGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGFic0NvbnRlbnRDb250YWluZXIpIHtcbiAgICAgICAgICBhY3RpdmVDb250ZW50W3N0eWxlXVtmbG9hdF0gPSBsZWZ0O1xuICAgICAgICAgIG5leHRDb250ZW50W3N0eWxlXVtmbG9hdF0gPSBsZWZ0OyAgICAgICAgXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gYWN0aXZlQ29udGVudFtzY3JvbGxIZWlnaHRdO1xuICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIGFkZENsYXNzKG5leHRDb250ZW50LGFjdGl2ZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd0V2ZW50LCBjb21wb25lbnQsIGFjdGl2ZVRhYik7XG4gIFxuICAgICAgICByZW1vdmVDbGFzcyhhY3RpdmVDb250ZW50LGFjdGl2ZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRkZW5FdmVudCwgY29tcG9uZW50LCBuZXh0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICAgIG5leHRIZWlnaHQgPSBuZXh0Q29udGVudFtzY3JvbGxIZWlnaHRdO1xuICAgICAgICAgIGVxdWFsQ29udGVudHMgPSBuZXh0SGVpZ2h0ID09PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYWRkQ2xhc3ModGFic0NvbnRlbnRDb250YWluZXIsY29sbGFwc2luZyk7XG4gICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXJbc3R5bGVdW2hlaWdodF0gPSBjb250YWluZXJIZWlnaHQgKyAncHgnOyAvLyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXJbb2Zmc2V0SGVpZ2h0XTtcbiAgICAgICAgICBhY3RpdmVDb250ZW50W3N0eWxlXVtmbG9hdF0gPSAnJztcbiAgICAgICAgICBuZXh0Q29udGVudFtzdHlsZV1bZmxvYXRdID0gJyc7ICAgXG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICggaGFzQ2xhc3MobmV4dENvbnRlbnQsICdmYWRlJykgKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgYWRkQ2xhc3MobmV4dENvbnRlbnQsc2hvd0NsYXNzKTtcbiAgICAgICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG5leHRDb250ZW50LHRyaWdnZXJTaG93KTtcbiAgICAgICAgICB9LDIwKTtcbiAgICAgICAgfSBlbHNlIHsgdHJpZ2dlclNob3coKTsgfSAgICAgICAgXG4gICAgICB9O1xuICBcbiAgICBpZiAoIXRhYnMpIHJldHVybjsgLy8gaW52YWxpZGF0ZVxuICBcbiAgICAvLyBzZXQgZGVmYXVsdCBhbmltYXRpb24gc3RhdGVcbiAgICB0YWJzW2lzQW5pbWF0aW5nXSA9IGZhbHNlOyAgICBcbiAgICAgICAgICBcbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICB2YXIgZ2V0QWN0aXZlVGFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhY3RpdmVUYWJzID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSh0YWJzLGFjdGl2ZSksIGFjdGl2ZVRhYjtcbiAgICAgICAgaWYgKCBhY3RpdmVUYWJzW2xlbmd0aF0gPT09IDEgJiYgIWhhc0NsYXNzKGFjdGl2ZVRhYnNbMF1bcGFyZW50Tm9kZV0sJ2Ryb3Bkb3duJykgKSB7XG4gICAgICAgICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1swXTtcbiAgICAgICAgfSBlbHNlIGlmICggYWN0aXZlVGFic1tsZW5ndGhdID4gMSApIHtcbiAgICAgICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzW2FjdGl2ZVRhYnNbbGVuZ3RoXS0xXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlVGFiO1xuICAgICAgfSxcbiAgICAgIGdldEFjdGl2ZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5RWxlbWVudChnZXRBY3RpdmVUYWIoKVtnZXRBdHRyaWJ1dGVdKCdocmVmJykpO1xuICAgICAgfSxcbiAgICAgIC8vIGhhbmRsZXIgXG4gICAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBocmVmID0gZVt0YXJnZXRdW2dldEF0dHJpYnV0ZV0oJ2hyZWYnKTtcbiAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgbmV4dCA9IGVbdGFyZ2V0XVtnZXRBdHRyaWJ1dGVdKGRhdGFUb2dnbGUpID09PSBjb21wb25lbnQgfHwgKGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJylcbiAgICAgICAgICAgICA/IGVbdGFyZ2V0XSA6IGVbdGFyZ2V0XVtwYXJlbnROb2RlXTsgLy8gYWxsb3cgZm9yIGNoaWxkIGVsZW1lbnRzIGxpa2UgaWNvbnMgdG8gdXNlIHRoZSBoYW5kbGVyXG4gICAgICAgICF0YWJzW2lzQW5pbWF0aW5nXSAmJiAhaGFzQ2xhc3MobmV4dCxhY3RpdmUpICYmIHNlbGYuc2hvdygpO1xuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkgeyAvLyB0aGUgdGFiIHdlIGNsaWNrZWQgaXMgbm93IHRoZSBuZXh0IHRhYlxuICAgICAgbmV4dCA9IG5leHQgfHwgZWxlbWVudDtcbiAgICAgIG5leHRDb250ZW50ID0gcXVlcnlFbGVtZW50KG5leHRbZ2V0QXR0cmlidXRlXSgnaHJlZicpKTsgLy90aGlzIGlzIHRoZSBhY3R1YWwgb2JqZWN0LCB0aGUgbmV4dCB0YWIgY29udGVudCB0byBhY3RpdmF0ZVxuICAgICAgYWN0aXZlVGFiID0gZ2V0QWN0aXZlVGFiKCk7IFxuICAgICAgYWN0aXZlQ29udGVudCA9IGdldEFjdGl2ZUNvbnRlbnQoKTtcbiAgICAgIFxuICAgICAgdGFic1tpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgcmVtb3ZlQ2xhc3MoYWN0aXZlVGFiLGFjdGl2ZSk7XG4gICAgICBhZGRDbGFzcyhuZXh0LGFjdGl2ZSk7XG4gIFxuICAgICAgaWYgKCBkcm9wZG93biApIHtcbiAgICAgICAgaWYgKCAhaGFzQ2xhc3MoZWxlbWVudFtwYXJlbnROb2RlXSwnZHJvcGRvd24tbWVudScpICkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyhkcm9wZG93bixhY3RpdmUpKSByZW1vdmVDbGFzcyhkcm9wZG93bixhY3RpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaGFzQ2xhc3MoZHJvcGRvd24sYWN0aXZlKSkgYWRkQ2xhc3MoZHJvcGRvd24sYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGFjdGl2ZVRhYiwgaGlkZUV2ZW50LCBjb21wb25lbnQsIG5leHQpO1xuICBcbiAgICAgIGlmIChoYXNDbGFzcyhhY3RpdmVDb250ZW50LCAnZmFkZScpKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGFjdGl2ZUNvbnRlbnQsc2hvd0NsYXNzKTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoYWN0aXZlQ29udGVudCwgdHJpZ2dlckhpZGUpO1xuICAgICAgfSBlbHNlIHsgdHJpZ2dlckhpZGUoKTsgfVxuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICBpZiAoICEoc3RyaW5nVGFiIGluIGVsZW1lbnQpICkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHNlbGZbaGVpZ2h0XSkgeyB0YWJzQ29udGVudENvbnRhaW5lciA9IGdldEFjdGl2ZUNvbnRlbnQoKVtwYXJlbnROb2RlXTsgfVxuICAgIGVsZW1lbnRbc3RyaW5nVGFiXSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBUQUIgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ1RhYiwgVGFiLCAnWycrZGF0YVRvZ2dsZSsnPVwidGFiXCJdJyBdICk7XG4gIFxuICBcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVG9vbHRpcFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gVE9PTFRJUCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uKCBlbGVtZW50LG9wdGlvbnMgKSB7XG4gIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBhbmltYXRpb25EYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFBbmltYXRpb24pLFxuICAgICAgICBwbGFjZW1lbnREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFQbGFjZW1lbnQpLFxuICAgICAgICBkZWxheURhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YURlbGF5KSxcbiAgICAgICAgY29udGFpbmVyRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQ29udGFpbmVyKSxcbiAgICAgICAgXG4gICAgICAgIC8vIHN0cmluZ3NcbiAgICAgICAgY29tcG9uZW50ID0gJ3Rvb2x0aXAnLFxuICAgICAgICBjbGFzc1N0cmluZyA9ICdjbGFzcycsXG4gICAgICAgIHRpdGxlID0gJ3RpdGxlJyxcbiAgICAgICAgZmFkZSA9ICdmYWRlJyxcbiAgICAgICAgZGl2ID0gJ2RpdicsXG4gIFxuICAgICAgICAvLyBjaGVjayBjb250YWluZXJcbiAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zW2NvbnRhaW5lcl0pLFxuICAgICAgICBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChjb250YWluZXJEYXRhKSwgICAgICBcbiAgXG4gICAgICAgIC8vIG1heWJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIG1vZGFsXG4gICAgICAgIG1vZGFsID0gZ2V0Q2xvc2VzdChlbGVtZW50LCcubW9kYWwnKSxcbiAgICAgICAgXG4gICAgICAgIC8vIG1heWJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIGZpeGVkIG5hdmJhclxuICAgICAgICBuYXZiYXJGaXhlZFRvcCA9IGdldENsb3Nlc3QoZWxlbWVudCwnLicrZml4ZWRUb3ApLFxuICAgICAgICBuYXZiYXJGaXhlZEJvdHRvbSA9IGdldENsb3Nlc3QoZWxlbWVudCwnLicrZml4ZWRCb3R0b20pO1xuICBcbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHRoaXNbYW5pbWF0aW9uXSA9IG9wdGlvbnNbYW5pbWF0aW9uXSAmJiBvcHRpb25zW2FuaW1hdGlvbl0gIT09IGZhZGUgPyBvcHRpb25zW2FuaW1hdGlvbl0gOiBhbmltYXRpb25EYXRhIHx8IGZhZGU7XG4gICAgdGhpc1twbGFjZW1lbnRdID0gb3B0aW9uc1twbGFjZW1lbnRdID8gb3B0aW9uc1twbGFjZW1lbnRdIDogcGxhY2VtZW50RGF0YSB8fCB0b3A7XG4gICAgdGhpc1tkZWxheV0gPSBwYXJzZUludChvcHRpb25zW2RlbGF5XSB8fCBkZWxheURhdGEpIHx8IDIwMDtcbiAgICB0aGlzW2NvbnRhaW5lcl0gPSBjb250YWluZXJFbGVtZW50ID8gY29udGFpbmVyRWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXJEYXRhRWxlbWVudCA/IGNvbnRhaW5lckRhdGFFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRUb3AgPyBuYXZiYXJGaXhlZFRvcFxuICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgOiBtb2RhbCA/IG1vZGFsIDogRE9DW2JvZHldO1xuICBcbiAgICAvLyBiaW5kLCBldmVudCB0YXJnZXRzLCB0aXRsZSBhbmQgY29uc3RhbnRzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCB0aW1lciA9IDAsIHBsYWNlbWVudFNldHRpbmcgPSB0aGlzW3BsYWNlbWVudF0sIHRvb2x0aXAgPSBudWxsLFxuICAgICAgdGl0bGVTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0odGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhT3JpZ2luYWxUaXRsZSk7XG4gIFxuICAgIGlmICggIXRpdGxlU3RyaW5nIHx8IHRpdGxlU3RyaW5nID09IFwiXCIgKSByZXR1cm47IC8vIGludmFsaWRhdGVcbiAgXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgdmFyIHJlbW92ZVRvb2xUaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZltjb250YWluZXJdLnJlbW92ZUNoaWxkKHRvb2x0aXApO1xuICAgICAgICB0b29sdGlwID0gbnVsbDsgdGltZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVRvb2xUaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGl0bGVTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0odGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhT3JpZ2luYWxUaXRsZSk7IC8vIHJlYWQgdGhlIHRpdGxlIGFnYWluXG4gICAgICAgIGlmICggIXRpdGxlU3RyaW5nIHx8IHRpdGxlU3RyaW5nID09IFwiXCIgKSByZXR1cm4gZmFsc2U7IC8vIGludmFsaWRhdGVcbiAgICAgICAgdG9vbHRpcCA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICB0b29sdGlwW3NldEF0dHJpYnV0ZV0oJ3JvbGUnLGNvbXBvbmVudCk7XG4gIFxuICAgICAgICAvLyB0b29sdGlwIGFycm93XG4gICAgICAgIHZhciB0b29sdGlwQXJyb3cgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgdG9vbHRpcEFycm93W3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsJ2Fycm93Jyk7XG4gICAgICAgIHRvb2x0aXBbYXBwZW5kQ2hpbGRdKHRvb2x0aXBBcnJvdyk7XG4gICAgXG4gICAgICAgIHZhciB0b29sdGlwSW5uZXIgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgdG9vbHRpcElubmVyW3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsY29tcG9uZW50KyctaW5uZXInKTtcbiAgICAgICAgdG9vbHRpcFthcHBlbmRDaGlsZF0odG9vbHRpcElubmVyKTtcbiAgICAgICAgdG9vbHRpcElubmVyW2lubmVySFRNTF0gPSB0aXRsZVN0cmluZztcbiAgXG4gICAgICAgIHNlbGZbY29udGFpbmVyXVthcHBlbmRDaGlsZF0odG9vbHRpcCk7XG4gICAgICAgIHRvb2x0aXBbc2V0QXR0cmlidXRlXShjbGFzc1N0cmluZywgY29tcG9uZW50ICsgJyBicy0nICsgY29tcG9uZW50KyctJytwbGFjZW1lbnRTZXR0aW5nICsgJyAnICsgc2VsZlthbmltYXRpb25dKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZVRpcChlbGVtZW50LHRvb2x0aXAscGxhY2VtZW50U2V0dGluZyxzZWxmW2NvbnRhaW5lcl0pO1xuICAgICAgfSxcbiAgICAgIHNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAhaGFzQ2xhc3ModG9vbHRpcCxzaG93Q2xhc3MpICYmICggYWRkQ2xhc3ModG9vbHRpcCxzaG93Q2xhc3MpICk7XG4gICAgICB9LFxuICAgICAgLy8gdHJpZ2dlcnNcbiAgICAgIHNob3dUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uKCBnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLmhpZGUgKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93bkV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgfSxcbiAgICAgIGhpZGVUcmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZiggZ2xvYmFsT2JqZWN0LCByZXNpemVFdmVudCwgc2VsZi5oaWRlICk7XG4gICAgICAgIHJlbW92ZVRvb2xUaXAoKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50KTtcbiAgICAgIH07XG4gIFxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICBwbGFjZW1lbnRTZXR0aW5nID0gc2VsZltwbGFjZW1lbnRdOyAvLyB3ZSByZXNldCBwbGFjZW1lbnQgaW4gYWxsIGNhc2VzXG4gICAgICAgICAgaWYoY3JlYXRlVG9vbFRpcCgpID09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgdXBkYXRlVG9vbHRpcCgpO1xuICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93RXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgISFzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBzaG93VHJpZ2dlcikgOiBzaG93VHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCApO1xuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgJiYgaGFzQ2xhc3ModG9vbHRpcCxzaG93Q2xhc3MpKSB7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcCxzaG93Q2xhc3MpO1xuICAgICAgICAgICEhc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgaGlkZVRyaWdnZXIpIDogaGlkZVRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2VsZltkZWxheV0pO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdG9vbHRpcCkgeyBzZWxmLnNob3coKTsgfSBcbiAgICAgIGVsc2UgeyBzZWxmLmhpZGUoKTsgfVxuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICBpZiAoICEoc3RyaW5nVG9vbHRpcCBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIGVsZW1lbnRbc2V0QXR0cmlidXRlXShkYXRhT3JpZ2luYWxUaXRsZSx0aXRsZVN0cmluZyk7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0aXRsZSk7XG4gICAgICBvbihlbGVtZW50LCBtb3VzZUhvdmVyWzBdLCBzZWxmLnNob3cpO1xuICAgICAgb24oZWxlbWVudCwgbW91c2VIb3ZlclsxXSwgc2VsZi5oaWRlKTtcbiAgICB9XG4gICAgZWxlbWVudFtzdHJpbmdUb29sdGlwXSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBUT09MVElQIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ1Rvb2x0aXAsIFRvb2x0aXAsICdbJytkYXRhVG9nZ2xlKyc9XCJ0b29sdGlwXCJdJyBdICk7XG4gIFxuICBcbiAgXHJcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgSW5pdGlhbGl6ZSBEYXRhIEFQSVxyXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICB2YXIgaW5pdGlhbGl6ZURhdGFBUEkgPSBmdW5jdGlvbiggY29uc3RydWN0b3IsIGNvbGxlY3Rpb24gKXtcclxuICAgICAgZm9yICh2YXIgaT0wLCBsPWNvbGxlY3Rpb25bbGVuZ3RoXTsgaTxsOyBpKyspIHtcclxuICAgICAgICBuZXcgY29uc3RydWN0b3IoY29sbGVjdGlvbltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbml0Q2FsbGJhY2sgPSBCU04uaW5pdENhbGxiYWNrID0gZnVuY3Rpb24obG9va1VwKXtcclxuICAgICAgbG9va1VwID0gbG9va1VwIHx8IERPQztcclxuICAgICAgZm9yICh2YXIgaT0wLCBsPXN1cHBvcnRzW2xlbmd0aF07IGk8bDsgaSsrKSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZURhdGFBUEkoIHN1cHBvcnRzW2ldWzFdLCBsb29rVXBbcXVlcnlTZWxlY3RvckFsbF0gKHN1cHBvcnRzW2ldWzJdKSApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIFxyXG4gIC8vIGJ1bGsgaW5pdGlhbGl6ZSBhbGwgY29tcG9uZW50c1xyXG4gIERPQ1tib2R5XSA/IGluaXRDYWxsYmFjaygpIDogb24oIERPQywgJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpeyBpbml0Q2FsbGJhY2soKTsgfSApO1xyXG4gIFxuICByZXR1cm4ge1xuICAgIEFsZXJ0OiBBbGVydCxcbiAgICBCdXR0b246IEJ1dHRvbixcbiAgICBDYXJvdXNlbDogQ2Fyb3VzZWwsXG4gICAgQ29sbGFwc2U6IENvbGxhcHNlLFxuICAgIERyb3Bkb3duOiBEcm9wZG93bixcbiAgICBNb2RhbDogTW9kYWwsXG4gICAgUG9wb3ZlcjogUG9wb3ZlcixcbiAgICBTY3JvbGxTcHk6IFNjcm9sbFNweSxcbiAgICBUYWI6IFRhYixcbiAgICBUb29sdGlwOiBUb29sdGlwXG4gIH07XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS12NC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},
/*!*********************************!*\
  !*** ./client/styles/site.scss ***!
  \*********************************/
/*! dynamic exports provided */
/*! all exports used */function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NsaWVudC9zdHlsZXMvc2l0ZS5zY3NzPzY1YzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9zdHlsZXMvc2l0ZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n")}]);